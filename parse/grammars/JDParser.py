# Generated from grammars\JD.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3 ")
        buf.write("\u00ac\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\62\n")
        buf.write("\3\3\3\5\3\65\n\3\3\3\5\38\n\3\3\3\3\3\3\4\3\4\3\4\5\4")
        buf.write("?\n\4\3\4\5\4B\n\4\3\4\5\4E\n\4\3\4\5\4H\n\4\3\4\5\4K")
        buf.write("\n\4\3\4\5\4N\n\4\3\4\5\4Q\n\4\3\4\5\4T\n\4\3\4\5\4W\n")
        buf.write("\4\3\4\5\4Z\n\4\3\4\3\4\3\5\3\5\3\5\3\6\3\6\3\6\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\6\bn\n\b\r\b\16\bo")
        buf.write("\3\t\3\t\6\tt\n\t\r\t\16\tu\3\n\3\n\6\nz\n\n\r\n\16\n")
        buf.write("{\3\13\3\13\6\13\u0080\n\13\r\13\16\13\u0081\3\f\3\f\3")
        buf.write("\f\3\f\5\f\u0088\n\f\3\f\5\f\u008b\n\f\3\f\3\f\3\r\3\r")
        buf.write("\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\20\3\20\3\20")
        buf.write("\3\21\3\21\3\21\3\21\3\22\3\22\6\22\u00a2\n\22\r\22\16")
        buf.write("\22\u00a3\3\23\3\23\6\23\u00a8\n\23\r\23\16\23\u00a9\3")
        buf.write("\23\2\2\24\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$")
        buf.write("\2\2\2\u00ae\2&\3\2\2\2\4)\3\2\2\2\6;\3\2\2\2\b]\3\2\2")
        buf.write("\2\n`\3\2\2\2\fc\3\2\2\2\16k\3\2\2\2\20q\3\2\2\2\22w\3")
        buf.write("\2\2\2\24}\3\2\2\2\26\u0083\3\2\2\2\30\u008e\3\2\2\2\32")
        buf.write("\u0091\3\2\2\2\34\u0094\3\2\2\2\36\u0098\3\2\2\2 \u009b")
        buf.write("\3\2\2\2\"\u009f\3\2\2\2$\u00a5\3\2\2\2&\'\5\4\3\2\'(")
        buf.write("\5\6\4\2(\3\3\2\2\2)*\7\4\2\2*+\7\25\2\2+,\5\b\5\2,-\5")
        buf.write("\n\6\2-.\5\f\7\2./\5\26\f\2/\61\5 \21\2\60\62\5\36\20")
        buf.write("\2\61\60\3\2\2\2\61\62\3\2\2\2\62\64\3\2\2\2\63\65\5\"")
        buf.write("\22\2\64\63\3\2\2\2\64\65\3\2\2\2\65\67\3\2\2\2\668\5")
        buf.write("$\23\2\67\66\3\2\2\2\678\3\2\2\289\3\2\2\29:\7\26\2\2")
        buf.write(":\5\3\2\2\2;<\7\5\2\2<>\7\25\2\2=?\5\16\b\2>=\3\2\2\2")
        buf.write(">?\3\2\2\2?A\3\2\2\2@B\5\20\t\2A@\3\2\2\2AB\3\2\2\2BD")
        buf.write("\3\2\2\2CE\5\22\n\2DC\3\2\2\2DE\3\2\2\2EG\3\2\2\2FH\5")
        buf.write("\24\13\2GF\3\2\2\2GH\3\2\2\2HJ\3\2\2\2IK\5\32\16\2JI\3")
        buf.write("\2\2\2JK\3\2\2\2KM\3\2\2\2LN\5\34\17\2ML\3\2\2\2MN\3\2")
        buf.write("\2\2NP\3\2\2\2OQ\5 \21\2PO\3\2\2\2PQ\3\2\2\2QS\3\2\2\2")
        buf.write("RT\5\36\20\2SR\3\2\2\2ST\3\2\2\2TV\3\2\2\2UW\5\"\22\2")
        buf.write("VU\3\2\2\2VW\3\2\2\2WY\3\2\2\2XZ\5$\23\2YX\3\2\2\2YZ\3")
        buf.write("\2\2\2Z[\3\2\2\2[\\\7\26\2\2\\\7\3\2\2\2]^\7\6\2\2^_\7")
        buf.write("\27\2\2_\t\3\2\2\2`a\7\7\2\2ab\7\30\2\2b\13\3\2\2\2cd")
        buf.write("\7\b\2\2de\7\25\2\2ef\5\16\b\2fg\5\20\t\2gh\5\22\n\2h")
        buf.write("i\5\24\13\2ij\7\26\2\2j\r\3\2\2\2km\7\16\2\2ln\7\37\2")
        buf.write("\2ml\3\2\2\2no\3\2\2\2om\3\2\2\2op\3\2\2\2p\17\3\2\2\2")
        buf.write("qs\7\17\2\2rt\7\37\2\2sr\3\2\2\2tu\3\2\2\2us\3\2\2\2u")
        buf.write("v\3\2\2\2v\21\3\2\2\2wy\7\20\2\2xz\7\37\2\2yx\3\2\2\2")
        buf.write("z{\3\2\2\2{y\3\2\2\2{|\3\2\2\2|\23\3\2\2\2}\177\7\21\2")
        buf.write("\2~\u0080\7\37\2\2\177~\3\2\2\2\u0080\u0081\3\2\2\2\u0081")
        buf.write("\177\3\2\2\2\u0081\u0082\3\2\2\2\u0082\25\3\2\2\2\u0083")
        buf.write("\u0084\7\t\2\2\u0084\u0085\7\25\2\2\u0085\u0087\5\30\r")
        buf.write("\2\u0086\u0088\5\32\16\2\u0087\u0086\3\2\2\2\u0087\u0088")
        buf.write("\3\2\2\2\u0088\u008a\3\2\2\2\u0089\u008b\5\34\17\2\u008a")
        buf.write("\u0089\3\2\2\2\u008a\u008b\3\2\2\2\u008b\u008c\3\2\2\2")
        buf.write("\u008c\u008d\7\26\2\2\u008d\27\3\2\2\2\u008e\u008f\7\22")
        buf.write("\2\2\u008f\u0090\7\32\2\2\u0090\31\3\2\2\2\u0091\u0092")
        buf.write("\7\23\2\2\u0092\u0093\7\31\2\2\u0093\33\3\2\2\2\u0094")
        buf.write("\u0095\7\24\2\2\u0095\u0096\7\33\2\2\u0096\u0097\7\36")
        buf.write("\2\2\u0097\35\3\2\2\2\u0098\u0099\7\n\2\2\u0099\u009a")
        buf.write("\7\34\2\2\u009a\37\3\2\2\2\u009b\u009c\7\f\2\2\u009c\u009d")
        buf.write("\7\35\2\2\u009d\u009e\7\3\2\2\u009e!\3\2\2\2\u009f\u00a1")
        buf.write("\7\13\2\2\u00a0\u00a2\7\37\2\2\u00a1\u00a0\3\2\2\2\u00a2")
        buf.write("\u00a3\3\2\2\2\u00a3\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2")
        buf.write("\u00a4#\3\2\2\2\u00a5\u00a7\7\r\2\2\u00a6\u00a8\7\37\2")
        buf.write("\2\u00a7\u00a6\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\u00a7")
        buf.write("\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa%\3\2\2\2\27\61\64\67")
        buf.write(">ADGJMPSVYou{\u0081\u0087\u008a\u00a3\u00a9")
        return buf.getvalue()


class JDParser ( Parser ):

    grammarFileName = "JD.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'years of experience'", "'REQUIREMENTS'", 
                     "'PREFERENCES'", "'position:'", "'level:'", "'stack:'", 
                     "'education:'", "'language:'", "'activities:'", "'experience:'", 
                     "'references:'", "'tools:'", "'programming languages:'", 
                     "'framework libraries:'", "'databases cloud services:'", 
                     "'major:'", "'degree:'", "'gpa:'", "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "REQUIRE_SECTION", "PREFER_SECTION", 
                      "POSITION_LABEL", "LEVEL_LABEL", "STACK_SECTION", 
                      "EDU_SECTION", "LANG_LABEL", "ACTIVITY_LABEL", "EXP_LABEL", 
                      "REF_LABEL", "TOOL_LABEL", "PROG_LANG_LABEL", "FRAMEWORK_LABEL", 
                      "DATA_LABEL", "MAJOR_LABEL", "DEGREE_LABEL", "GPA_LABEL", 
                      "OPEN_CURLY", "CLOSE_CURLY", "POSITION", "LEVEL", 
                      "DEGREE", "MAJOR", "COMPARATOR", "LANGUAGE", "INT", 
                      "FLOAT", "ID", "WS" ]

    RULE_program = 0
    RULE_requirements = 1
    RULE_preferences = 2
    RULE_requirePosition = 3
    RULE_requireLevel = 4
    RULE_requireTechnicalSkills = 5
    RULE_requireTools = 6
    RULE_requireProLang = 7
    RULE_requireFrameworks = 8
    RULE_requireDB = 9
    RULE_requireEducation = 10
    RULE_requireMajor = 11
    RULE_requireDegree = 12
    RULE_requireGPA = 13
    RULE_requireLanguage = 14
    RULE_requireExperience = 15
    RULE_requireActivites = 16
    RULE_requireReferences = 17

    ruleNames =  [ "program", "requirements", "preferences", "requirePosition", 
                   "requireLevel", "requireTechnicalSkills", "requireTools", 
                   "requireProLang", "requireFrameworks", "requireDB", "requireEducation", 
                   "requireMajor", "requireDegree", "requireGPA", "requireLanguage", 
                   "requireExperience", "requireActivites", "requireReferences" ]

    EOF = Token.EOF
    T__0=1
    REQUIRE_SECTION=2
    PREFER_SECTION=3
    POSITION_LABEL=4
    LEVEL_LABEL=5
    STACK_SECTION=6
    EDU_SECTION=7
    LANG_LABEL=8
    ACTIVITY_LABEL=9
    EXP_LABEL=10
    REF_LABEL=11
    TOOL_LABEL=12
    PROG_LANG_LABEL=13
    FRAMEWORK_LABEL=14
    DATA_LABEL=15
    MAJOR_LABEL=16
    DEGREE_LABEL=17
    GPA_LABEL=18
    OPEN_CURLY=19
    CLOSE_CURLY=20
    POSITION=21
    LEVEL=22
    DEGREE=23
    MAJOR=24
    COMPARATOR=25
    LANGUAGE=26
    INT=27
    FLOAT=28
    ID=29
    WS=30

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(JDParser.RequirementsContext,0)


        def preferences(self):
            return self.getTypedRuleContext(JDParser.PreferencesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_program




    def program(self):

        localctx = JDParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 36
            self.requirements()
            self.state = 37
            self.preferences()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRE_SECTION(self):
            return self.getToken(JDParser.REQUIRE_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requirePosition(self):
            return self.getTypedRuleContext(JDParser.RequirePositionContext,0)


        def requireLevel(self):
            return self.getTypedRuleContext(JDParser.RequireLevelContext,0)


        def requireTechnicalSkills(self):
            return self.getTypedRuleContext(JDParser.RequireTechnicalSkillsContext,0)


        def requireEducation(self):
            return self.getTypedRuleContext(JDParser.RequireEducationContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDParser.RequireActivitesContext,0)


        def requireReferences(self):
            return self.getTypedRuleContext(JDParser.RequireReferencesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requirements




    def requirements(self):

        localctx = JDParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.match(JDParser.REQUIRE_SECTION)
            self.state = 40
            self.match(JDParser.OPEN_CURLY)
            self.state = 41
            self.requirePosition()
            self.state = 42
            self.requireLevel()
            self.state = 43
            self.requireTechnicalSkills()
            self.state = 44
            self.requireEducation()
            self.state = 45
            self.requireExperience()
            self.state = 47
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 46
                self.requireLanguage()


            self.state = 50
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.ACTIVITY_LABEL:
                self.state = 49
                self.requireActivites()


            self.state = 53
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.REF_LABEL:
                self.state = 52
                self.requireReferences()


            self.state = 55
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREFER_SECTION(self):
            return self.getToken(JDParser.PREFER_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDParser.RequireActivitesContext,0)


        def requireReferences(self):
            return self.getTypedRuleContext(JDParser.RequireReferencesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_preferences




    def preferences(self):

        localctx = JDParser.PreferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_preferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self.match(JDParser.PREFER_SECTION)
            self.state = 58
            self.match(JDParser.OPEN_CURLY)
            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.TOOL_LABEL:
                self.state = 59
                self.requireTools()


            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.PROG_LANG_LABEL:
                self.state = 62
                self.requireProLang()


            self.state = 66
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.FRAMEWORK_LABEL:
                self.state = 65
                self.requireFrameworks()


            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DATA_LABEL:
                self.state = 68
                self.requireDB()


            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 71
                self.requireDegree()


            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 74
                self.requireGPA()


            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.EXP_LABEL:
                self.state = 77
                self.requireExperience()


            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 80
                self.requireLanguage()


            self.state = 84
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.ACTIVITY_LABEL:
                self.state = 83
                self.requireActivites()


            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.REF_LABEL:
                self.state = 86
                self.requireReferences()


            self.state = 89
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirePositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION_LABEL(self):
            return self.getToken(JDParser.POSITION_LABEL, 0)

        def POSITION(self):
            return self.getToken(JDParser.POSITION, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requirePosition




    def requirePosition(self):

        localctx = JDParser.RequirePositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_requirePosition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.match(JDParser.POSITION_LABEL)
            self.state = 92
            self.match(JDParser.POSITION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEVEL_LABEL(self):
            return self.getToken(JDParser.LEVEL_LABEL, 0)

        def LEVEL(self):
            return self.getToken(JDParser.LEVEL, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireLevel




    def requireLevel(self):

        localctx = JDParser.RequireLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_requireLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(JDParser.LEVEL_LABEL)
            self.state = 95
            self.match(JDParser.LEVEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireTechnicalSkillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACK_SECTION(self):
            return self.getToken(JDParser.STACK_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireTechnicalSkills




    def requireTechnicalSkills(self):

        localctx = JDParser.RequireTechnicalSkillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_requireTechnicalSkills)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self.match(JDParser.STACK_SECTION)
            self.state = 98
            self.match(JDParser.OPEN_CURLY)
            self.state = 99
            self.requireTools()
            self.state = 100
            self.requireProLang()
            self.state = 101
            self.requireFrameworks()
            self.state = 102
            self.requireDB()
            self.state = 103
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireToolsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOOL_LABEL(self):
            return self.getToken(JDParser.TOOL_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireTools




    def requireTools(self):

        localctx = JDParser.RequireToolsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_requireTools)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(JDParser.TOOL_LABEL)
            self.state = 107 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 106
                self.match(JDParser.ID)
                self.state = 109 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireProLangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROG_LANG_LABEL(self):
            return self.getToken(JDParser.PROG_LANG_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireProLang




    def requireProLang(self):

        localctx = JDParser.RequireProLangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_requireProLang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(JDParser.PROG_LANG_LABEL)
            self.state = 113 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 112
                self.match(JDParser.ID)
                self.state = 115 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireFrameworksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FRAMEWORK_LABEL(self):
            return self.getToken(JDParser.FRAMEWORK_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireFrameworks




    def requireFrameworks(self):

        localctx = JDParser.RequireFrameworksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_requireFrameworks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(JDParser.FRAMEWORK_LABEL)
            self.state = 119 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 118
                self.match(JDParser.ID)
                self.state = 121 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDBContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA_LABEL(self):
            return self.getToken(JDParser.DATA_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireDB




    def requireDB(self):

        localctx = JDParser.RequireDBContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_requireDB)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(JDParser.DATA_LABEL)
            self.state = 125 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 124
                self.match(JDParser.ID)
                self.state = 127 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireEducationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EDU_SECTION(self):
            return self.getToken(JDParser.EDU_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireMajor(self):
            return self.getTypedRuleContext(JDParser.RequireMajorContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireEducation




    def requireEducation(self):

        localctx = JDParser.RequireEducationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_requireEducation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(JDParser.EDU_SECTION)
            self.state = 130
            self.match(JDParser.OPEN_CURLY)
            self.state = 131
            self.requireMajor()
            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 132
                self.requireDegree()


            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 135
                self.requireGPA()


            self.state = 138
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireMajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAJOR_LABEL(self):
            return self.getToken(JDParser.MAJOR_LABEL, 0)

        def MAJOR(self):
            return self.getToken(JDParser.MAJOR, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireMajor




    def requireMajor(self):

        localctx = JDParser.RequireMajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_requireMajor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(JDParser.MAJOR_LABEL)
            self.state = 141
            self.match(JDParser.MAJOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEGREE_LABEL(self):
            return self.getToken(JDParser.DEGREE_LABEL, 0)

        def DEGREE(self):
            return self.getToken(JDParser.DEGREE, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireDegree




    def requireDegree(self):

        localctx = JDParser.RequireDegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_requireDegree)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(JDParser.DEGREE_LABEL)
            self.state = 144
            self.match(JDParser.DEGREE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireGPAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GPA_LABEL(self):
            return self.getToken(JDParser.GPA_LABEL, 0)

        def COMPARATOR(self):
            return self.getToken(JDParser.COMPARATOR, 0)

        def FLOAT(self):
            return self.getToken(JDParser.FLOAT, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireGPA




    def requireGPA(self):

        localctx = JDParser.RequireGPAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_requireGPA)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(JDParser.GPA_LABEL)
            self.state = 147
            self.match(JDParser.COMPARATOR)
            self.state = 148
            self.match(JDParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANG_LABEL(self):
            return self.getToken(JDParser.LANG_LABEL, 0)

        def LANGUAGE(self):
            return self.getToken(JDParser.LANGUAGE, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireLanguage




    def requireLanguage(self):

        localctx = JDParser.RequireLanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_requireLanguage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(JDParser.LANG_LABEL)
            self.state = 151
            self.match(JDParser.LANGUAGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireExperienceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXP_LABEL(self):
            return self.getToken(JDParser.EXP_LABEL, 0)

        def INT(self):
            return self.getToken(JDParser.INT, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireExperience




    def requireExperience(self):

        localctx = JDParser.RequireExperienceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_requireExperience)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(JDParser.EXP_LABEL)
            self.state = 154
            self.match(JDParser.INT)
            self.state = 155
            self.match(JDParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireActivitesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTIVITY_LABEL(self):
            return self.getToken(JDParser.ACTIVITY_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireActivites




    def requireActivites(self):

        localctx = JDParser.RequireActivitesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_requireActivites)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(JDParser.ACTIVITY_LABEL)
            self.state = 159 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 158
                self.match(JDParser.ID)
                self.state = 161 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireReferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REF_LABEL(self):
            return self.getToken(JDParser.REF_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireReferences




    def requireReferences(self):

        localctx = JDParser.RequireReferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_requireReferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(JDParser.REF_LABEL)
            self.state = 165 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 164
                self.match(JDParser.ID)
                self.state = 167 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





