# Generated from JDMatcher.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3%")
        buf.write("\u00d7\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\3\2\3\2\3\2\3")
        buf.write("\2\5\2\63\n\2\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4F\n\4\3\5\3\5\3\5\3\5")
        buf.write("\3\5\3\6\3\6\5\6O\n\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\5\7Y\n\7\3\7\5\7\\\n\7\3\7\5\7_\n\7\3\7\3\7\3\b\3\b\3")
        buf.write("\b\5\bf\n\b\3\b\5\bi\n\b\3\b\5\bl\n\b\3\b\5\bo\n\b\3\b")
        buf.write("\5\br\n\b\3\b\5\bu\n\b\3\b\5\bx\n\b\3\b\5\b{\n\b\3\b\5")
        buf.write("\b~\n\b\3\b\5\b\u0081\n\b\3\b\3\b\3\t\3\t\3\t\3\n\3\n")
        buf.write("\3\n\3\13\3\13\3\13\3\13\3\13\5\13\u0090\n\13\3\13\5\13")
        buf.write("\u0093\n\13\3\13\3\13\3\f\3\f\6\f\u0099\n\f\r\f\16\f\u009a")
        buf.write("\3\r\3\r\6\r\u009f\n\r\r\r\16\r\u00a0\3\16\3\16\6\16\u00a5")
        buf.write("\n\16\r\16\16\16\u00a6\3\17\3\17\6\17\u00ab\n\17\r\17")
        buf.write("\16\17\u00ac\3\20\3\20\3\20\3\20\5\20\u00b3\n\20\3\20")
        buf.write("\5\20\u00b6\n\20\3\20\3\20\3\21\3\21\3\21\3\22\3\22\3")
        buf.write("\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\25\3\25")
        buf.write("\3\25\3\26\3\26\6\26\u00cd\n\26\r\26\16\26\u00ce\3\27")
        buf.write("\3\27\6\27\u00d3\n\27\r\27\16\27\u00d4\3\27\2\2\30\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,\2\2\2\u00e5")
        buf.write("\2\62\3\2\2\2\4\64\3\2\2\2\6\67\3\2\2\2\bG\3\2\2\2\nL")
        buf.write("\3\2\2\2\fP\3\2\2\2\16b\3\2\2\2\20\u0084\3\2\2\2\22\u0087")
        buf.write("\3\2\2\2\24\u008a\3\2\2\2\26\u0096\3\2\2\2\30\u009c\3")
        buf.write("\2\2\2\32\u00a2\3\2\2\2\34\u00a8\3\2\2\2\36\u00ae\3\2")
        buf.write("\2\2 \u00b9\3\2\2\2\"\u00bc\3\2\2\2$\u00bf\3\2\2\2&\u00c3")
        buf.write("\3\2\2\2(\u00c7\3\2\2\2*\u00ca\3\2\2\2,\u00d0\3\2\2\2")
        buf.write(".\63\5\4\3\2/\63\5\n\6\2\60\63\5\b\5\2\61\63\5\6\4\2\62")
        buf.write(".\3\2\2\2\62/\3\2\2\2\62\60\3\2\2\2\62\61\3\2\2\2\63\3")
        buf.write("\3\2\2\2\64\65\7\4\2\2\65\66\7\34\2\2\66\5\3\2\2\2\67")
        buf.write("8\7\6\2\289\5\20\t\29E\7\b\2\2:F\5\22\n\2;F\5\26\f\2<")
        buf.write("F\5\30\r\2=F\5\32\16\2>F\5\34\17\2?F\5\"\22\2@F\5$\23")
        buf.write("\2AF\5&\24\2BF\5(\25\2CF\5*\26\2DF\5,\27\2E:\3\2\2\2E")
        buf.write(";\3\2\2\2E<\3\2\2\2E=\3\2\2\2E>\3\2\2\2E?\3\2\2\2E@\3")
        buf.write("\2\2\2EA\3\2\2\2EB\3\2\2\2EC\3\2\2\2ED\3\2\2\2F\7\3\2")
        buf.write("\2\2GH\7\5\2\2HI\7\"\2\2IJ\7\7\2\2JK\7\34\2\2K\t\3\2\2")
        buf.write("\2LN\5\f\7\2MO\5\16\b\2NM\3\2\2\2NO\3\2\2\2O\13\3\2\2")
        buf.write("\2PQ\7\t\2\2QR\7\32\2\2RS\5\20\t\2ST\5\22\n\2TU\5\24\13")
        buf.write("\2UV\5\36\20\2VX\5&\24\2WY\5(\25\2XW\3\2\2\2XY\3\2\2\2")
        buf.write("Y[\3\2\2\2Z\\\5*\26\2[Z\3\2\2\2[\\\3\2\2\2\\^\3\2\2\2")
        buf.write("]_\5,\27\2^]\3\2\2\2^_\3\2\2\2_`\3\2\2\2`a\7\33\2\2a\r")
        buf.write("\3\2\2\2bc\7\n\2\2ce\7\32\2\2df\5\26\f\2ed\3\2\2\2ef\3")
        buf.write("\2\2\2fh\3\2\2\2gi\5\30\r\2hg\3\2\2\2hi\3\2\2\2ik\3\2")
        buf.write("\2\2jl\5\32\16\2kj\3\2\2\2kl\3\2\2\2ln\3\2\2\2mo\5\34")
        buf.write("\17\2nm\3\2\2\2no\3\2\2\2oq\3\2\2\2pr\5\"\22\2qp\3\2\2")
        buf.write("\2qr\3\2\2\2rt\3\2\2\2su\5$\23\2ts\3\2\2\2tu\3\2\2\2u")
        buf.write("w\3\2\2\2vx\5&\24\2wv\3\2\2\2wx\3\2\2\2xz\3\2\2\2y{\5")
        buf.write("(\25\2zy\3\2\2\2z{\3\2\2\2{}\3\2\2\2|~\5*\26\2}|\3\2\2")
        buf.write("\2}~\3\2\2\2~\u0080\3\2\2\2\177\u0081\5,\27\2\u0080\177")
        buf.write("\3\2\2\2\u0080\u0081\3\2\2\2\u0081\u0082\3\2\2\2\u0082")
        buf.write("\u0083\7\33\2\2\u0083\17\3\2\2\2\u0084\u0085\7\13\2\2")
        buf.write("\u0085\u0086\7\34\2\2\u0086\21\3\2\2\2\u0087\u0088\7\f")
        buf.write("\2\2\u0088\u0089\7\35\2\2\u0089\23\3\2\2\2\u008a\u008b")
        buf.write("\7\r\2\2\u008b\u008c\7\32\2\2\u008c\u008d\5\26\f\2\u008d")
        buf.write("\u008f\5\30\r\2\u008e\u0090\5\32\16\2\u008f\u008e\3\2")
        buf.write("\2\2\u008f\u0090\3\2\2\2\u0090\u0092\3\2\2\2\u0091\u0093")
        buf.write("\5\34\17\2\u0092\u0091\3\2\2\2\u0092\u0093\3\2\2\2\u0093")
        buf.write("\u0094\3\2\2\2\u0094\u0095\7\33\2\2\u0095\25\3\2\2\2\u0096")
        buf.write("\u0098\7\23\2\2\u0097\u0099\7$\2\2\u0098\u0097\3\2\2\2")
        buf.write("\u0099\u009a\3\2\2\2\u009a\u0098\3\2\2\2\u009a\u009b\3")
        buf.write("\2\2\2\u009b\27\3\2\2\2\u009c\u009e\7\24\2\2\u009d\u009f")
        buf.write("\7$\2\2\u009e\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0")
        buf.write("\u009e\3\2\2\2\u00a0\u00a1\3\2\2\2\u00a1\31\3\2\2\2\u00a2")
        buf.write("\u00a4\7\25\2\2\u00a3\u00a5\7$\2\2\u00a4\u00a3\3\2\2\2")
        buf.write("\u00a5\u00a6\3\2\2\2\u00a6\u00a4\3\2\2\2\u00a6\u00a7\3")
        buf.write("\2\2\2\u00a7\33\3\2\2\2\u00a8\u00aa\7\26\2\2\u00a9\u00ab")
        buf.write("\7$\2\2\u00aa\u00a9\3\2\2\2\u00ab\u00ac\3\2\2\2\u00ac")
        buf.write("\u00aa\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\35\3\2\2\2\u00ae")
        buf.write("\u00af\7\16\2\2\u00af\u00b0\7\32\2\2\u00b0\u00b2\5 \21")
        buf.write("\2\u00b1\u00b3\5\"\22\2\u00b2\u00b1\3\2\2\2\u00b2\u00b3")
        buf.write("\3\2\2\2\u00b3\u00b5\3\2\2\2\u00b4\u00b6\5$\23\2\u00b5")
        buf.write("\u00b4\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7\3\2\2\2")
        buf.write("\u00b7\u00b8\7\33\2\2\u00b8\37\3\2\2\2\u00b9\u00ba\7\27")
        buf.write("\2\2\u00ba\u00bb\7\37\2\2\u00bb!\3\2\2\2\u00bc\u00bd\7")
        buf.write("\30\2\2\u00bd\u00be\7\36\2\2\u00be#\3\2\2\2\u00bf\u00c0")
        buf.write("\7\31\2\2\u00c0\u00c1\7 \2\2\u00c1\u00c2\7#\2\2\u00c2")
        buf.write("%\3\2\2\2\u00c3\u00c4\7\21\2\2\u00c4\u00c5\7\"\2\2\u00c5")
        buf.write("\u00c6\7\3\2\2\u00c6\'\3\2\2\2\u00c7\u00c8\7\17\2\2\u00c8")
        buf.write("\u00c9\7!\2\2\u00c9)\3\2\2\2\u00ca\u00cc\7\20\2\2\u00cb")
        buf.write("\u00cd\7$\2\2\u00cc\u00cb\3\2\2\2\u00cd\u00ce\3\2\2\2")
        buf.write("\u00ce\u00cc\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cf+\3\2\2")
        buf.write("\2\u00d0\u00d2\7\22\2\2\u00d1\u00d3\7$\2\2\u00d2\u00d1")
        buf.write("\3\2\2\2\u00d3\u00d4\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4")
        buf.write("\u00d5\3\2\2\2\u00d5-\3\2\2\2\34\62ENX[^ehknqtwz}\u0080")
        buf.write("\u008f\u0092\u009a\u00a0\u00a6\u00ac\u00b2\u00b5\u00ce")
        buf.write("\u00d4")
        return buf.getvalue()


class JDMatcherParser ( Parser ):

    grammarFileName = "JDMatcher.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'years'", "'list all CVs for job'", "'show top'", 
                     "'show CV with'", "'best CV for'", "'and'", "'REQUIREMENTS'", 
                     "'PREFERENCES'", "'position:'", "'level:'", "'stack'", 
                     "'education'", "'language:'", "'activities:'", "'experience:'", 
                     "'references:'", "'tools:'", "'programming languages:'", 
                     "'framework libraries:'", "'databases cloud services:'", 
                     "'major:'", "'degree:'", "'gpa:'", "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "LIST_CV", "SHOW_TOP", "SHOW_CV_WITH", 
                      "BEST_FOR", "AND", "REQUIRE_SECTION", "PREFER_SECTION", 
                      "POSITION_LABEL", "LEVEL_LABEL", "STACK_SECTION", 
                      "EDU_SECTION", "LANG_LABEL", "ACTIVITY_LABEL", "EXP_LABEL", 
                      "REF_LABEL", "TOOL_LABEL", "PROG_LANG_LABEL", "FRAMEWORK_LABEL", 
                      "DATA_LABEL", "MAJOR_LABEL", "DEGREE_LABEL", "GPA_LABEL", 
                      "OPEN_CURLY", "CLOSE_CURLY", "POSITION", "LEVEL", 
                      "DEGREE", "MAJOR", "COMPARATOR", "LANGUAGE", "INT", 
                      "FLOAT", "ID", "WS" ]

    RULE_program = 0
    RULE_listCV = 1
    RULE_showConditional = 2
    RULE_show_X_best = 3
    RULE_jd = 4
    RULE_requirements = 5
    RULE_preferences = 6
    RULE_requirePosition = 7
    RULE_requireLevel = 8
    RULE_requireTechnicalSkills = 9
    RULE_requireTools = 10
    RULE_requireProLang = 11
    RULE_requireFrameworks = 12
    RULE_requireDB = 13
    RULE_requireEducation = 14
    RULE_requireMajor = 15
    RULE_requireDegree = 16
    RULE_requireGPA = 17
    RULE_requireExperience = 18
    RULE_requireLanguage = 19
    RULE_requireActivites = 20
    RULE_requireReferences = 21

    ruleNames =  [ "program", "listCV", "showConditional", "show_X_best", 
                   "jd", "requirements", "preferences", "requirePosition", 
                   "requireLevel", "requireTechnicalSkills", "requireTools", 
                   "requireProLang", "requireFrameworks", "requireDB", "requireEducation", 
                   "requireMajor", "requireDegree", "requireGPA", "requireExperience", 
                   "requireLanguage", "requireActivites", "requireReferences" ]

    EOF = Token.EOF
    T__0=1
    LIST_CV=2
    SHOW_TOP=3
    SHOW_CV_WITH=4
    BEST_FOR=5
    AND=6
    REQUIRE_SECTION=7
    PREFER_SECTION=8
    POSITION_LABEL=9
    LEVEL_LABEL=10
    STACK_SECTION=11
    EDU_SECTION=12
    LANG_LABEL=13
    ACTIVITY_LABEL=14
    EXP_LABEL=15
    REF_LABEL=16
    TOOL_LABEL=17
    PROG_LANG_LABEL=18
    FRAMEWORK_LABEL=19
    DATA_LABEL=20
    MAJOR_LABEL=21
    DEGREE_LABEL=22
    GPA_LABEL=23
    OPEN_CURLY=24
    CLOSE_CURLY=25
    POSITION=26
    LEVEL=27
    DEGREE=28
    MAJOR=29
    COMPARATOR=30
    LANGUAGE=31
    INT=32
    FLOAT=33
    ID=34
    WS=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def listCV(self):
            return self.getTypedRuleContext(JDMatcherParser.ListCVContext,0)


        def jd(self):
            return self.getTypedRuleContext(JDMatcherParser.JdContext,0)


        def show_X_best(self):
            return self.getTypedRuleContext(JDMatcherParser.Show_X_bestContext,0)


        def showConditional(self):
            return self.getTypedRuleContext(JDMatcherParser.ShowConditionalContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = JDMatcherParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.state = 48
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JDMatcherParser.LIST_CV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.listCV()
                pass
            elif token in [JDMatcherParser.REQUIRE_SECTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.jd()
                pass
            elif token in [JDMatcherParser.SHOW_TOP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.show_X_best()
                pass
            elif token in [JDMatcherParser.SHOW_CV_WITH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 47
                self.showConditional()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListCVContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIST_CV(self):
            return self.getToken(JDMatcherParser.LIST_CV, 0)

        def POSITION(self):
            return self.getToken(JDMatcherParser.POSITION, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_listCV

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListCV" ):
                listener.enterListCV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListCV" ):
                listener.exitListCV(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListCV" ):
                return visitor.visitListCV(self)
            else:
                return visitor.visitChildren(self)




    def listCV(self):

        localctx = JDMatcherParser.ListCVContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_listCV)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.match(JDMatcherParser.LIST_CV)
            self.state = 51
            self.match(JDMatcherParser.POSITION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowConditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_CV_WITH(self):
            return self.getToken(JDMatcherParser.SHOW_CV_WITH, 0)

        def requirePosition(self):
            return self.getTypedRuleContext(JDMatcherParser.RequirePositionContext,0)


        def AND(self):
            return self.getToken(JDMatcherParser.AND, 0)

        def requireLevel(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireLevelContext,0)


        def requireTools(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireActivitesContext,0)


        def requireReferences(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireReferencesContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_showConditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowConditional" ):
                listener.enterShowConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowConditional" ):
                listener.exitShowConditional(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowConditional" ):
                return visitor.visitShowConditional(self)
            else:
                return visitor.visitChildren(self)




    def showConditional(self):

        localctx = JDMatcherParser.ShowConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_showConditional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(JDMatcherParser.SHOW_CV_WITH)
            self.state = 54
            self.requirePosition()
            self.state = 55
            self.match(JDMatcherParser.AND)
            self.state = 67
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JDMatcherParser.LEVEL_LABEL]:
                self.state = 56
                self.requireLevel()
                pass
            elif token in [JDMatcherParser.TOOL_LABEL]:
                self.state = 57
                self.requireTools()
                pass
            elif token in [JDMatcherParser.PROG_LANG_LABEL]:
                self.state = 58
                self.requireProLang()
                pass
            elif token in [JDMatcherParser.FRAMEWORK_LABEL]:
                self.state = 59
                self.requireFrameworks()
                pass
            elif token in [JDMatcherParser.DATA_LABEL]:
                self.state = 60
                self.requireDB()
                pass
            elif token in [JDMatcherParser.DEGREE_LABEL]:
                self.state = 61
                self.requireDegree()
                pass
            elif token in [JDMatcherParser.GPA_LABEL]:
                self.state = 62
                self.requireGPA()
                pass
            elif token in [JDMatcherParser.EXP_LABEL]:
                self.state = 63
                self.requireExperience()
                pass
            elif token in [JDMatcherParser.LANG_LABEL]:
                self.state = 64
                self.requireLanguage()
                pass
            elif token in [JDMatcherParser.ACTIVITY_LABEL]:
                self.state = 65
                self.requireActivites()
                pass
            elif token in [JDMatcherParser.REF_LABEL]:
                self.state = 66
                self.requireReferences()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Show_X_bestContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_TOP(self):
            return self.getToken(JDMatcherParser.SHOW_TOP, 0)

        def INT(self):
            return self.getToken(JDMatcherParser.INT, 0)

        def BEST_FOR(self):
            return self.getToken(JDMatcherParser.BEST_FOR, 0)

        def POSITION(self):
            return self.getToken(JDMatcherParser.POSITION, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_show_X_best

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShow_X_best" ):
                listener.enterShow_X_best(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShow_X_best" ):
                listener.exitShow_X_best(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShow_X_best" ):
                return visitor.visitShow_X_best(self)
            else:
                return visitor.visitChildren(self)




    def show_X_best(self):

        localctx = JDMatcherParser.Show_X_bestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_show_X_best)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(JDMatcherParser.SHOW_TOP)
            self.state = 70
            self.match(JDMatcherParser.INT)
            self.state = 71
            self.match(JDMatcherParser.BEST_FOR)
            self.state = 72
            self.match(JDMatcherParser.POSITION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(JDMatcherParser.RequirementsContext,0)


        def preferences(self):
            return self.getTypedRuleContext(JDMatcherParser.PreferencesContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_jd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJd" ):
                listener.enterJd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJd" ):
                listener.exitJd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJd" ):
                return visitor.visitJd(self)
            else:
                return visitor.visitChildren(self)




    def jd(self):

        localctx = JDMatcherParser.JdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_jd)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.requirements()
            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.PREFER_SECTION:
                self.state = 75
                self.preferences()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRE_SECTION(self):
            return self.getToken(JDMatcherParser.REQUIRE_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDMatcherParser.OPEN_CURLY, 0)

        def requirePosition(self):
            return self.getTypedRuleContext(JDMatcherParser.RequirePositionContext,0)


        def requireLevel(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireLevelContext,0)


        def requireTechnicalSkills(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireTechnicalSkillsContext,0)


        def requireEducation(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireEducationContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireExperienceContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDMatcherParser.CLOSE_CURLY, 0)

        def requireLanguage(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireActivitesContext,0)


        def requireReferences(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireReferencesContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_requirements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirements" ):
                listener.enterRequirements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirements" ):
                listener.exitRequirements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequirements" ):
                return visitor.visitRequirements(self)
            else:
                return visitor.visitChildren(self)




    def requirements(self):

        localctx = JDMatcherParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(JDMatcherParser.REQUIRE_SECTION)
            self.state = 79
            self.match(JDMatcherParser.OPEN_CURLY)
            self.state = 80
            self.requirePosition()
            self.state = 81
            self.requireLevel()
            self.state = 82
            self.requireTechnicalSkills()
            self.state = 83
            self.requireEducation()
            self.state = 84
            self.requireExperience()
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.LANG_LABEL:
                self.state = 85
                self.requireLanguage()


            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.ACTIVITY_LABEL:
                self.state = 88
                self.requireActivites()


            self.state = 92
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.REF_LABEL:
                self.state = 91
                self.requireReferences()


            self.state = 94
            self.match(JDMatcherParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREFER_SECTION(self):
            return self.getToken(JDMatcherParser.PREFER_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDMatcherParser.OPEN_CURLY, 0)

        def CLOSE_CURLY(self):
            return self.getToken(JDMatcherParser.CLOSE_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireActivitesContext,0)


        def requireReferences(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireReferencesContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_preferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreferences" ):
                listener.enterPreferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreferences" ):
                listener.exitPreferences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreferences" ):
                return visitor.visitPreferences(self)
            else:
                return visitor.visitChildren(self)




    def preferences(self):

        localctx = JDMatcherParser.PreferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_preferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.match(JDMatcherParser.PREFER_SECTION)
            self.state = 97
            self.match(JDMatcherParser.OPEN_CURLY)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.TOOL_LABEL:
                self.state = 98
                self.requireTools()


            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.PROG_LANG_LABEL:
                self.state = 101
                self.requireProLang()


            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.FRAMEWORK_LABEL:
                self.state = 104
                self.requireFrameworks()


            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.DATA_LABEL:
                self.state = 107
                self.requireDB()


            self.state = 111
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.DEGREE_LABEL:
                self.state = 110
                self.requireDegree()


            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.GPA_LABEL:
                self.state = 113
                self.requireGPA()


            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.EXP_LABEL:
                self.state = 116
                self.requireExperience()


            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.LANG_LABEL:
                self.state = 119
                self.requireLanguage()


            self.state = 123
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.ACTIVITY_LABEL:
                self.state = 122
                self.requireActivites()


            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.REF_LABEL:
                self.state = 125
                self.requireReferences()


            self.state = 128
            self.match(JDMatcherParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirePositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION_LABEL(self):
            return self.getToken(JDMatcherParser.POSITION_LABEL, 0)

        def POSITION(self):
            return self.getToken(JDMatcherParser.POSITION, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requirePosition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirePosition" ):
                listener.enterRequirePosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirePosition" ):
                listener.exitRequirePosition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequirePosition" ):
                return visitor.visitRequirePosition(self)
            else:
                return visitor.visitChildren(self)




    def requirePosition(self):

        localctx = JDMatcherParser.RequirePositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_requirePosition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(JDMatcherParser.POSITION_LABEL)
            self.state = 131
            self.match(JDMatcherParser.POSITION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEVEL_LABEL(self):
            return self.getToken(JDMatcherParser.LEVEL_LABEL, 0)

        def LEVEL(self):
            return self.getToken(JDMatcherParser.LEVEL, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLevel" ):
                listener.enterRequireLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLevel" ):
                listener.exitRequireLevel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireLevel" ):
                return visitor.visitRequireLevel(self)
            else:
                return visitor.visitChildren(self)




    def requireLevel(self):

        localctx = JDMatcherParser.RequireLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_requireLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(JDMatcherParser.LEVEL_LABEL)
            self.state = 134
            self.match(JDMatcherParser.LEVEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireTechnicalSkillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACK_SECTION(self):
            return self.getToken(JDMatcherParser.STACK_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDMatcherParser.OPEN_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireProLangContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDMatcherParser.CLOSE_CURLY, 0)

        def requireFrameworks(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDBContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireTechnicalSkills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTechnicalSkills" ):
                listener.enterRequireTechnicalSkills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTechnicalSkills" ):
                listener.exitRequireTechnicalSkills(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireTechnicalSkills" ):
                return visitor.visitRequireTechnicalSkills(self)
            else:
                return visitor.visitChildren(self)




    def requireTechnicalSkills(self):

        localctx = JDMatcherParser.RequireTechnicalSkillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_requireTechnicalSkills)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(JDMatcherParser.STACK_SECTION)
            self.state = 137
            self.match(JDMatcherParser.OPEN_CURLY)
            self.state = 138
            self.requireTools()
            self.state = 139
            self.requireProLang()
            self.state = 141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.FRAMEWORK_LABEL:
                self.state = 140
                self.requireFrameworks()


            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.DATA_LABEL:
                self.state = 143
                self.requireDB()


            self.state = 146
            self.match(JDMatcherParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireToolsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOOL_LABEL(self):
            return self.getToken(JDMatcherParser.TOOL_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireTools

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTools" ):
                listener.enterRequireTools(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTools" ):
                listener.exitRequireTools(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireTools" ):
                return visitor.visitRequireTools(self)
            else:
                return visitor.visitChildren(self)




    def requireTools(self):

        localctx = JDMatcherParser.RequireToolsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_requireTools)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(JDMatcherParser.TOOL_LABEL)
            self.state = 150 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 149
                self.match(JDMatcherParser.ID)
                self.state = 152 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireProLangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROG_LANG_LABEL(self):
            return self.getToken(JDMatcherParser.PROG_LANG_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireProLang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireProLang" ):
                listener.enterRequireProLang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireProLang" ):
                listener.exitRequireProLang(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireProLang" ):
                return visitor.visitRequireProLang(self)
            else:
                return visitor.visitChildren(self)




    def requireProLang(self):

        localctx = JDMatcherParser.RequireProLangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_requireProLang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(JDMatcherParser.PROG_LANG_LABEL)
            self.state = 156 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 155
                self.match(JDMatcherParser.ID)
                self.state = 158 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireFrameworksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FRAMEWORK_LABEL(self):
            return self.getToken(JDMatcherParser.FRAMEWORK_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireFrameworks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireFrameworks" ):
                listener.enterRequireFrameworks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireFrameworks" ):
                listener.exitRequireFrameworks(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireFrameworks" ):
                return visitor.visitRequireFrameworks(self)
            else:
                return visitor.visitChildren(self)




    def requireFrameworks(self):

        localctx = JDMatcherParser.RequireFrameworksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_requireFrameworks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(JDMatcherParser.FRAMEWORK_LABEL)
            self.state = 162 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 161
                self.match(JDMatcherParser.ID)
                self.state = 164 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDBContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA_LABEL(self):
            return self.getToken(JDMatcherParser.DATA_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireDB

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDB" ):
                listener.enterRequireDB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDB" ):
                listener.exitRequireDB(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireDB" ):
                return visitor.visitRequireDB(self)
            else:
                return visitor.visitChildren(self)




    def requireDB(self):

        localctx = JDMatcherParser.RequireDBContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_requireDB)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(JDMatcherParser.DATA_LABEL)
            self.state = 168 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 167
                self.match(JDMatcherParser.ID)
                self.state = 170 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireEducationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EDU_SECTION(self):
            return self.getToken(JDMatcherParser.EDU_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDMatcherParser.OPEN_CURLY, 0)

        def requireMajor(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireMajorContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDMatcherParser.CLOSE_CURLY, 0)

        def requireDegree(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDMatcherParser.RequireGPAContext,0)


        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireEducation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireEducation" ):
                listener.enterRequireEducation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireEducation" ):
                listener.exitRequireEducation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireEducation" ):
                return visitor.visitRequireEducation(self)
            else:
                return visitor.visitChildren(self)




    def requireEducation(self):

        localctx = JDMatcherParser.RequireEducationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_requireEducation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(JDMatcherParser.EDU_SECTION)
            self.state = 173
            self.match(JDMatcherParser.OPEN_CURLY)
            self.state = 174
            self.requireMajor()
            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.DEGREE_LABEL:
                self.state = 175
                self.requireDegree()


            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDMatcherParser.GPA_LABEL:
                self.state = 178
                self.requireGPA()


            self.state = 181
            self.match(JDMatcherParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireMajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAJOR_LABEL(self):
            return self.getToken(JDMatcherParser.MAJOR_LABEL, 0)

        def MAJOR(self):
            return self.getToken(JDMatcherParser.MAJOR, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireMajor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireMajor" ):
                listener.enterRequireMajor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireMajor" ):
                listener.exitRequireMajor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireMajor" ):
                return visitor.visitRequireMajor(self)
            else:
                return visitor.visitChildren(self)




    def requireMajor(self):

        localctx = JDMatcherParser.RequireMajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_requireMajor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(JDMatcherParser.MAJOR_LABEL)
            self.state = 184
            self.match(JDMatcherParser.MAJOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEGREE_LABEL(self):
            return self.getToken(JDMatcherParser.DEGREE_LABEL, 0)

        def DEGREE(self):
            return self.getToken(JDMatcherParser.DEGREE, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireDegree

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDegree" ):
                listener.enterRequireDegree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDegree" ):
                listener.exitRequireDegree(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireDegree" ):
                return visitor.visitRequireDegree(self)
            else:
                return visitor.visitChildren(self)




    def requireDegree(self):

        localctx = JDMatcherParser.RequireDegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_requireDegree)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(JDMatcherParser.DEGREE_LABEL)
            self.state = 187
            self.match(JDMatcherParser.DEGREE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireGPAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GPA_LABEL(self):
            return self.getToken(JDMatcherParser.GPA_LABEL, 0)

        def COMPARATOR(self):
            return self.getToken(JDMatcherParser.COMPARATOR, 0)

        def FLOAT(self):
            return self.getToken(JDMatcherParser.FLOAT, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireGPA

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireGPA" ):
                listener.enterRequireGPA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireGPA" ):
                listener.exitRequireGPA(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireGPA" ):
                return visitor.visitRequireGPA(self)
            else:
                return visitor.visitChildren(self)




    def requireGPA(self):

        localctx = JDMatcherParser.RequireGPAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_requireGPA)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(JDMatcherParser.GPA_LABEL)
            self.state = 190
            self.match(JDMatcherParser.COMPARATOR)
            self.state = 191
            self.match(JDMatcherParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireExperienceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXP_LABEL(self):
            return self.getToken(JDMatcherParser.EXP_LABEL, 0)

        def INT(self):
            return self.getToken(JDMatcherParser.INT, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireExperience

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireExperience" ):
                listener.enterRequireExperience(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireExperience" ):
                listener.exitRequireExperience(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireExperience" ):
                return visitor.visitRequireExperience(self)
            else:
                return visitor.visitChildren(self)




    def requireExperience(self):

        localctx = JDMatcherParser.RequireExperienceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_requireExperience)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(JDMatcherParser.EXP_LABEL)
            self.state = 194
            self.match(JDMatcherParser.INT)
            self.state = 195
            self.match(JDMatcherParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANG_LABEL(self):
            return self.getToken(JDMatcherParser.LANG_LABEL, 0)

        def LANGUAGE(self):
            return self.getToken(JDMatcherParser.LANGUAGE, 0)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireLanguage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLanguage" ):
                listener.enterRequireLanguage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLanguage" ):
                listener.exitRequireLanguage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireLanguage" ):
                return visitor.visitRequireLanguage(self)
            else:
                return visitor.visitChildren(self)




    def requireLanguage(self):

        localctx = JDMatcherParser.RequireLanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_requireLanguage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(JDMatcherParser.LANG_LABEL)
            self.state = 198
            self.match(JDMatcherParser.LANGUAGE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireActivitesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTIVITY_LABEL(self):
            return self.getToken(JDMatcherParser.ACTIVITY_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireActivites

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireActivites" ):
                listener.enterRequireActivites(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireActivites" ):
                listener.exitRequireActivites(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireActivites" ):
                return visitor.visitRequireActivites(self)
            else:
                return visitor.visitChildren(self)




    def requireActivites(self):

        localctx = JDMatcherParser.RequireActivitesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_requireActivites)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(JDMatcherParser.ACTIVITY_LABEL)
            self.state = 202 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 201
                self.match(JDMatcherParser.ID)
                self.state = 204 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireReferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REF_LABEL(self):
            return self.getToken(JDMatcherParser.REF_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDMatcherParser.ID)
            else:
                return self.getToken(JDMatcherParser.ID, i)

        def getRuleIndex(self):
            return JDMatcherParser.RULE_requireReferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireReferences" ):
                listener.enterRequireReferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireReferences" ):
                listener.exitRequireReferences(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRequireReferences" ):
                return visitor.visitRequireReferences(self)
            else:
                return visitor.visitChildren(self)




    def requireReferences(self):

        localctx = JDMatcherParser.RequireReferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_requireReferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(JDMatcherParser.REF_LABEL)
            self.state = 208 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 207
                self.match(JDMatcherParser.ID)
                self.state = 210 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDMatcherParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





