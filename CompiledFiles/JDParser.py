# Generated from JD.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00af")
        buf.write("\u00f3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\3\2\3\2\3\2\5\2B\n\2\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5")
        buf.write("V\n\5\3\6\3\6\5\6Z\n\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\5\7d\n\7\3\7\3\7\3\b\3\b\3\b\5\bk\n\b\3\b\5\bn\n\b\3")
        buf.write("\b\5\bq\n\b\3\b\5\bt\n\b\3\b\5\bw\n\b\3\b\5\bz\n\b\3\b")
        buf.write("\5\b}\n\b\3\b\5\b\u0080\n\b\3\b\5\b\u0083\n\b\3\b\3\b")
        buf.write("\3\t\3\t\3\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\f\3\f\3\f\3\f\7\f\u0099\n\f\f\f\16\f\u009c")
        buf.write("\13\f\3\r\3\r\3\r\3\r\7\r\u00a2\n\r\f\r\16\r\u00a5\13")
        buf.write("\r\3\16\3\16\3\16\3\16\7\16\u00ab\n\16\f\16\16\16\u00ae")
        buf.write("\13\16\3\17\3\17\3\17\3\17\7\17\u00b4\n\17\f\17\16\17")
        buf.write("\u00b7\13\17\3\20\3\20\3\20\3\20\5\20\u00bd\n\20\3\20")
        buf.write("\5\20\u00c0\n\20\3\20\3\20\3\21\3\21\3\21\3\22\3\22\3")
        buf.write("\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\7\24\u00d2")
        buf.write("\n\24\f\24\16\24\u00d5\13\24\3\25\3\25\3\25\3\25\3\26")
        buf.write("\3\26\6\26\u00dd\n\26\r\26\16\26\u00de\3\27\3\27\3\30")
        buf.write("\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35\3\35")
        buf.write("\3\36\3\36\3\37\3\37\3\37\2\2 \2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(*,.\60\62\64\668:<\2\13\3\2\3\34")
        buf.write("\3\2\35#\3\2$\'\3\2(.\3\2/C\3\2DW\3\2Xu\3\2v\u008a\3\2")
        buf.write("\u008b\u0091\2\u00f2\2A\3\2\2\2\4C\3\2\2\2\6H\3\2\2\2")
        buf.write("\bU\3\2\2\2\nW\3\2\2\2\f[\3\2\2\2\16g\3\2\2\2\20\u0086")
        buf.write("\3\2\2\2\22\u0089\3\2\2\2\24\u008c\3\2\2\2\26\u0094\3")
        buf.write("\2\2\2\30\u009d\3\2\2\2\32\u00a6\3\2\2\2\34\u00af\3\2")
        buf.write("\2\2\36\u00b8\3\2\2\2 \u00c3\3\2\2\2\"\u00c6\3\2\2\2$")
        buf.write("\u00c9\3\2\2\2&\u00cd\3\2\2\2(\u00d6\3\2\2\2*\u00da\3")
        buf.write("\2\2\2,\u00e0\3\2\2\2.\u00e2\3\2\2\2\60\u00e4\3\2\2\2")
        buf.write("\62\u00e6\3\2\2\2\64\u00e8\3\2\2\2\66\u00ea\3\2\2\28\u00ec")
        buf.write("\3\2\2\2:\u00ee\3\2\2\2<\u00f0\3\2\2\2>B\5\n\6\2?B\5\4")
        buf.write("\3\2@B\5\6\4\2A>\3\2\2\2A?\3\2\2\2A@\3\2\2\2B\3\3\2\2")
        buf.write("\2CD\7\u00a4\2\2DE\7\u00a5\2\2EF\7\u00ac\2\2FG\7\u00a6")
        buf.write("\2\2G\5\3\2\2\2HI\7\u00a7\2\2IJ\5\b\5\2J\7\3\2\2\2KV\5")
        buf.write("\22\n\2LV\5\26\f\2MV\5\30\r\2NV\5\32\16\2OV\5\34\17\2")
        buf.write("PV\5\"\22\2QV\5$\23\2RV\5(\25\2SV\5&\24\2TV\5*\26\2UK")
        buf.write("\3\2\2\2UL\3\2\2\2UM\3\2\2\2UN\3\2\2\2UO\3\2\2\2UP\3\2")
        buf.write("\2\2UQ\3\2\2\2UR\3\2\2\2US\3\2\2\2UT\3\2\2\2V\t\3\2\2")
        buf.write("\2WY\5\f\7\2XZ\5\16\b\2YX\3\2\2\2YZ\3\2\2\2Z\13\3\2\2")
        buf.write("\2[\\\7\u0092\2\2\\]\7\u00a8\2\2]^\5\20\t\2^_\5\22\n\2")
        buf.write("_`\5\24\13\2`a\5\36\20\2ac\5(\25\2bd\5&\24\2cb\3\2\2\2")
        buf.write("cd\3\2\2\2de\3\2\2\2ef\7\u00a9\2\2f\r\3\2\2\2gh\7\u0093")
        buf.write("\2\2hj\7\u00a8\2\2ik\5\26\f\2ji\3\2\2\2jk\3\2\2\2km\3")
        buf.write("\2\2\2ln\5\30\r\2ml\3\2\2\2mn\3\2\2\2np\3\2\2\2oq\5\32")
        buf.write("\16\2po\3\2\2\2pq\3\2\2\2qs\3\2\2\2rt\5\34\17\2sr\3\2")
        buf.write("\2\2st\3\2\2\2tv\3\2\2\2uw\5\"\22\2vu\3\2\2\2vw\3\2\2")
        buf.write("\2wy\3\2\2\2xz\5$\23\2yx\3\2\2\2yz\3\2\2\2z|\3\2\2\2{")
        buf.write("}\5(\25\2|{\3\2\2\2|}\3\2\2\2}\177\3\2\2\2~\u0080\5&\24")
        buf.write("\2\177~\3\2\2\2\177\u0080\3\2\2\2\u0080\u0082\3\2\2\2")
        buf.write("\u0081\u0083\5*\26\2\u0082\u0081\3\2\2\2\u0082\u0083\3")
        buf.write("\2\2\2\u0083\u0084\3\2\2\2\u0084\u0085\7\u00a9\2\2\u0085")
        buf.write("\17\3\2\2\2\u0086\u0087\7\u0094\2\2\u0087\u0088\5,\27")
        buf.write("\2\u0088\21\3\2\2\2\u0089\u008a\7\u0095\2\2\u008a\u008b")
        buf.write("\5.\30\2\u008b\23\3\2\2\2\u008c\u008d\7\u0096\2\2\u008d")
        buf.write("\u008e\7\u00a8\2\2\u008e\u008f\5\26\f\2\u008f\u0090\5")
        buf.write("\30\r\2\u0090\u0091\5\32\16\2\u0091\u0092\5\34\17\2\u0092")
        buf.write("\u0093\7\u00a9\2\2\u0093\25\3\2\2\2\u0094\u0095\7\u009c")
        buf.write("\2\2\u0095\u009a\5\64\33\2\u0096\u0097\7\u00aa\2\2\u0097")
        buf.write("\u0099\5\64\33\2\u0098\u0096\3\2\2\2\u0099\u009c\3\2\2")
        buf.write("\2\u009a\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b\27\3")
        buf.write("\2\2\2\u009c\u009a\3\2\2\2\u009d\u009e\7\u009d\2\2\u009e")
        buf.write("\u00a3\5\66\34\2\u009f\u00a0\7\u00aa\2\2\u00a0\u00a2\5")
        buf.write("\66\34\2\u00a1\u009f\3\2\2\2\u00a2\u00a5\3\2\2\2\u00a3")
        buf.write("\u00a1\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\31\3\2\2\2\u00a5")
        buf.write("\u00a3\3\2\2\2\u00a6\u00a7\7\u009e\2\2\u00a7\u00ac\58")
        buf.write("\35\2\u00a8\u00a9\7\u00aa\2\2\u00a9\u00ab\58\35\2\u00aa")
        buf.write("\u00a8\3\2\2\2\u00ab\u00ae\3\2\2\2\u00ac\u00aa\3\2\2\2")
        buf.write("\u00ac\u00ad\3\2\2\2\u00ad\33\3\2\2\2\u00ae\u00ac\3\2")
        buf.write("\2\2\u00af\u00b0\7\u009f\2\2\u00b0\u00b5\5:\36\2\u00b1")
        buf.write("\u00b2\7\u00aa\2\2\u00b2\u00b4\5:\36\2\u00b3\u00b1\3\2")
        buf.write("\2\2\u00b4\u00b7\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b5\u00b6")
        buf.write("\3\2\2\2\u00b6\35\3\2\2\2\u00b7\u00b5\3\2\2\2\u00b8\u00b9")
        buf.write("\7\u0097\2\2\u00b9\u00ba\7\u00a8\2\2\u00ba\u00bc\5 \21")
        buf.write("\2\u00bb\u00bd\5\"\22\2\u00bc\u00bb\3\2\2\2\u00bc\u00bd")
        buf.write("\3\2\2\2\u00bd\u00bf\3\2\2\2\u00be\u00c0\5$\23\2\u00bf")
        buf.write("\u00be\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0\u00c1\3\2\2\2")
        buf.write("\u00c1\u00c2\7\u00a9\2\2\u00c2\37\3\2\2\2\u00c3\u00c4")
        buf.write("\7\u00a0\2\2\u00c4\u00c5\5\62\32\2\u00c5!\3\2\2\2\u00c6")
        buf.write("\u00c7\7\u00a1\2\2\u00c7\u00c8\5\60\31\2\u00c8#\3\2\2")
        buf.write("\2\u00c9\u00ca\7\u00a2\2\2\u00ca\u00cb\7\u00ab\2\2\u00cb")
        buf.write("\u00cc\7\u00ad\2\2\u00cc%\3\2\2\2\u00cd\u00ce\7\u0098")
        buf.write("\2\2\u00ce\u00d3\5<\37\2\u00cf\u00d0\7\u00aa\2\2\u00d0")
        buf.write("\u00d2\5<\37\2\u00d1\u00cf\3\2\2\2\u00d2\u00d5\3\2\2\2")
        buf.write("\u00d3\u00d1\3\2\2\2\u00d3\u00d4\3\2\2\2\u00d4\'\3\2\2")
        buf.write("\2\u00d5\u00d3\3\2\2\2\u00d6\u00d7\7\u009a\2\2\u00d7\u00d8")
        buf.write("\7\u00ac\2\2\u00d8\u00d9\7\u00a3\2\2\u00d9)\3\2\2\2\u00da")
        buf.write("\u00dc\7\u0099\2\2\u00db\u00dd\7\u00ae\2\2\u00dc\u00db")
        buf.write("\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u00dc\3\2\2\2\u00de")
        buf.write("\u00df\3\2\2\2\u00df+\3\2\2\2\u00e0\u00e1\t\2\2\2\u00e1")
        buf.write("-\3\2\2\2\u00e2\u00e3\t\3\2\2\u00e3/\3\2\2\2\u00e4\u00e5")
        buf.write("\t\4\2\2\u00e5\61\3\2\2\2\u00e6\u00e7\t\5\2\2\u00e7\63")
        buf.write("\3\2\2\2\u00e8\u00e9\t\6\2\2\u00e9\65\3\2\2\2\u00ea\u00eb")
        buf.write("\t\7\2\2\u00eb\67\3\2\2\2\u00ec\u00ed\t\b\2\2\u00ed9\3")
        buf.write("\2\2\2\u00ee\u00ef\t\t\2\2\u00ef;\3\2\2\2\u00f0\u00f1")
        buf.write("\t\n\2\2\u00f1=\3\2\2\2\27AUYcjmpsvy|\177\u0082\u009a")
        buf.write("\u00a3\u00ac\u00b5\u00bc\u00bf\u00d3\u00de")
        return buf.getvalue()


class JDParser ( Parser ):

    grammarFileName = "JD.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'frontend developer'", "'backend developer'", 
                     "'full-stack developer'", "'software engineer'", "'ai engineer'", 
                     "'ml engineer'", "'data scientist'", "'data engineer'", 
                     "'data analyst'", "'qa/qc engineer'", "'tester'", "'security engineer'", 
                     "'devops engineer'", "'cloud engineer'", "'network engineer'", 
                     "'embedded engineer'", "'mobile developer'", "'android developer'", 
                     "'ios developer'", "'solution architect'", "'technical lead'", 
                     "'product manager'", "'scrum master'", "'game developer'", 
                     "'blockchain developer'", "'research engineer'", "'intern'", 
                     "'fresher'", "'junior'", "'medium'", "'senior'", "'director'", 
                     "'manager'", "'bachelor'", "'engineering'", "'master'", 
                     "'phd'", "'computer science'", "'computer engineering'", 
                     "'network engineering'", "'data science'", "'artificial intelligence'", 
                     "'cybersecurity'", "'information systems'", "'git'", 
                     "'docker'", "'kubernetes'", "'jenkins'", "'jira'", 
                     "'postman'", "'webpack'", "'npm'", "'yarn'", "'vscode'", 
                     "'intellij'", "'eclipse'", "'figma'", "'trello'", "'slack'", 
                     "'notion'", "'aws cli'", "'gcp sdk'", "'azure cli'", 
                     "'terraform'", "'github actions'", "'python'", "'java'", 
                     "'c'", "'c++'", "'c#'", "'go'", "'rust'", "'javascript'", 
                     "'typescript'", "'ruby'", "'php'", "'swift'", "'kotlin'", 
                     "'scala'", "'r'", "'matlab'", "'bash'", "'sql'", "'haskell'", 
                     "'perl'", "'pytorch'", "'tensorflow'", "'keras'", "'scikit-learn'", 
                     "'xgboost'", "'lightgbm'", "'opencv'", "'flask'", "'django'", 
                     "'spring'", "'express'", "'fastapi'", "'next.js'", 
                     "'nuxt.js'", "'react'", "'vue'", "'angular'", "'bootstrap'", 
                     "'laravel'", "'.net'", "'asp.net'", "'electron'", "'flutter'", 
                     "'react native'", "'node.js'", "'nestjs'", "'redux'", 
                     "'mui'", "'tailwindcss'", "'springboot'", "'mysql'", 
                     "'postgresql'", "'sqlite'", "'mongodb'", "'redis'", 
                     "'mariadb'", "'oracle'", "'sql server'", "'dynamodb'", 
                     "'cassandra'", "'elasticsearch'", "'aws'", "'azure'", 
                     "'gcp'", "'google cloud'", "'amazon web services'", 
                     "'firebase'", "'heroku'", "'digitalocean'", "'vercel'", 
                     "'netlify'", "'english'", "'japanese'", "'chinese'", 
                     "'korean'", "'german'", "'portugeese'", "'french'", 
                     "'REQUIREMENTS'", "'PREFERENCES'", "'position:'", "'level:'", 
                     "'stack'", "'education'", "'language:'", "'activities:'", 
                     "'experience:'", "'references:'", "'tools:'", "'programming languages:'", 
                     "'framework libraries:'", "'databases cloud services:'", 
                     "'major:'", "'degree:'", "'gpa:'", "'years'", "'show'", 
                     "'top'", "'CV'", "'show CV with'", "'{'", "'}'", "','" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "REQUIRE_SECTION", "PREFER_SECTION", "POSITION_LABEL", 
                      "LEVEL_LABEL", "STACK_SECTION", "EDU_SECTION", "LANG_LABEL", 
                      "ACTIVITY_LABEL", "EXP_LABEL", "REF_LABEL", "TOOL_LABEL", 
                      "PROG_LANG_LABEL", "FRAMEWORK_LABEL", "DATA_LABEL", 
                      "MAJOR_LABEL", "DEGREE_LABEL", "GPA_LABEL", "YEARS", 
                      "SHOW", "TOP", "CV", "SHOW_CV_WITH", "OPEN_CURLY", 
                      "CLOSE_CURLY", "COMMA", "COMPARATOR", "INT", "FLOAT", 
                      "ID", "WS" ]

    RULE_program = 0
    RULE_showTop = 1
    RULE_showConditional = 2
    RULE_condition = 3
    RULE_jd = 4
    RULE_requirements = 5
    RULE_preferences = 6
    RULE_requirePosition = 7
    RULE_requireLevel = 8
    RULE_requireTechnicalSkills = 9
    RULE_requireTools = 10
    RULE_requireProLang = 11
    RULE_requireFrameworks = 12
    RULE_requireDB = 13
    RULE_requireEducation = 14
    RULE_requireMajor = 15
    RULE_requireDegree = 16
    RULE_requireGPA = 17
    RULE_requireLanguage = 18
    RULE_requireExperience = 19
    RULE_requireActivites = 20
    RULE_position = 21
    RULE_level = 22
    RULE_degree = 23
    RULE_major = 24
    RULE_tool = 25
    RULE_pro_lang = 26
    RULE_framework = 27
    RULE_db = 28
    RULE_lang = 29

    ruleNames =  [ "program", "showTop", "showConditional", "condition", 
                   "jd", "requirements", "preferences", "requirePosition", 
                   "requireLevel", "requireTechnicalSkills", "requireTools", 
                   "requireProLang", "requireFrameworks", "requireDB", "requireEducation", 
                   "requireMajor", "requireDegree", "requireGPA", "requireLanguage", 
                   "requireExperience", "requireActivites", "position", 
                   "level", "degree", "major", "tool", "pro_lang", "framework", 
                   "db", "lang" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    T__102=103
    T__103=104
    T__104=105
    T__105=106
    T__106=107
    T__107=108
    T__108=109
    T__109=110
    T__110=111
    T__111=112
    T__112=113
    T__113=114
    T__114=115
    T__115=116
    T__116=117
    T__117=118
    T__118=119
    T__119=120
    T__120=121
    T__121=122
    T__122=123
    T__123=124
    T__124=125
    T__125=126
    T__126=127
    T__127=128
    T__128=129
    T__129=130
    T__130=131
    T__131=132
    T__132=133
    T__133=134
    T__134=135
    T__135=136
    T__136=137
    T__137=138
    T__138=139
    T__139=140
    T__140=141
    T__141=142
    T__142=143
    REQUIRE_SECTION=144
    PREFER_SECTION=145
    POSITION_LABEL=146
    LEVEL_LABEL=147
    STACK_SECTION=148
    EDU_SECTION=149
    LANG_LABEL=150
    ACTIVITY_LABEL=151
    EXP_LABEL=152
    REF_LABEL=153
    TOOL_LABEL=154
    PROG_LANG_LABEL=155
    FRAMEWORK_LABEL=156
    DATA_LABEL=157
    MAJOR_LABEL=158
    DEGREE_LABEL=159
    GPA_LABEL=160
    YEARS=161
    SHOW=162
    TOP=163
    CV=164
    SHOW_CV_WITH=165
    OPEN_CURLY=166
    CLOSE_CURLY=167
    COMMA=168
    COMPARATOR=169
    INT=170
    FLOAT=171
    ID=172
    WS=173

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def jd(self):
            return self.getTypedRuleContext(JDParser.JdContext,0)


        def showTop(self):
            return self.getTypedRuleContext(JDParser.ShowTopContext,0)


        def showConditional(self):
            return self.getTypedRuleContext(JDParser.ShowConditionalContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = JDParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.state = 63
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JDParser.REQUIRE_SECTION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 60
                self.jd()
                pass
            elif token in [JDParser.SHOW]:
                self.enterOuterAlt(localctx, 2)
                self.state = 61
                self.showTop()
                pass
            elif token in [JDParser.SHOW_CV_WITH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 62
                self.showConditional()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowTopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW(self):
            return self.getToken(JDParser.SHOW, 0)

        def TOP(self):
            return self.getToken(JDParser.TOP, 0)

        def INT(self):
            return self.getToken(JDParser.INT, 0)

        def CV(self):
            return self.getToken(JDParser.CV, 0)

        def getRuleIndex(self):
            return JDParser.RULE_showTop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowTop" ):
                listener.enterShowTop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowTop" ):
                listener.exitShowTop(self)




    def showTop(self):

        localctx = JDParser.ShowTopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_showTop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.match(JDParser.SHOW)
            self.state = 66
            self.match(JDParser.TOP)
            self.state = 67
            self.match(JDParser.INT)
            self.state = 68
            self.match(JDParser.CV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowConditionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW_CV_WITH(self):
            return self.getToken(JDParser.SHOW_CV_WITH, 0)

        def condition(self):
            return self.getTypedRuleContext(JDParser.ConditionContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_showConditional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowConditional" ):
                listener.enterShowConditional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowConditional" ):
                listener.exitShowConditional(self)




    def showConditional(self):

        localctx = JDParser.ShowConditionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_showConditional)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.match(JDParser.SHOW_CV_WITH)
            self.state = 71
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requireLevel(self):
            return self.getTypedRuleContext(JDParser.RequireLevelContext,0)


        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDParser.RequireActivitesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = JDParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_condition)
        try:
            self.state = 83
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [JDParser.LEVEL_LABEL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 73
                self.requireLevel()
                pass
            elif token in [JDParser.TOOL_LABEL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.requireTools()
                pass
            elif token in [JDParser.PROG_LANG_LABEL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 75
                self.requireProLang()
                pass
            elif token in [JDParser.FRAMEWORK_LABEL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 76
                self.requireFrameworks()
                pass
            elif token in [JDParser.DATA_LABEL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 77
                self.requireDB()
                pass
            elif token in [JDParser.DEGREE_LABEL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 78
                self.requireDegree()
                pass
            elif token in [JDParser.GPA_LABEL]:
                self.enterOuterAlt(localctx, 7)
                self.state = 79
                self.requireGPA()
                pass
            elif token in [JDParser.EXP_LABEL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 80
                self.requireExperience()
                pass
            elif token in [JDParser.LANG_LABEL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 81
                self.requireLanguage()
                pass
            elif token in [JDParser.ACTIVITY_LABEL]:
                self.enterOuterAlt(localctx, 10)
                self.state = 82
                self.requireActivites()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JdContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(JDParser.RequirementsContext,0)


        def preferences(self):
            return self.getTypedRuleContext(JDParser.PreferencesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_jd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJd" ):
                listener.enterJd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJd" ):
                listener.exitJd(self)




    def jd(self):

        localctx = JDParser.JdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_jd)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.requirements()
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.PREFER_SECTION:
                self.state = 86
                self.preferences()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRE_SECTION(self):
            return self.getToken(JDParser.REQUIRE_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requirePosition(self):
            return self.getTypedRuleContext(JDParser.RequirePositionContext,0)


        def requireLevel(self):
            return self.getTypedRuleContext(JDParser.RequireLevelContext,0)


        def requireTechnicalSkills(self):
            return self.getTypedRuleContext(JDParser.RequireTechnicalSkillsContext,0)


        def requireEducation(self):
            return self.getTypedRuleContext(JDParser.RequireEducationContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requirements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirements" ):
                listener.enterRequirements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirements" ):
                listener.exitRequirements(self)




    def requirements(self):

        localctx = JDParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 89
            self.match(JDParser.REQUIRE_SECTION)
            self.state = 90
            self.match(JDParser.OPEN_CURLY)
            self.state = 91
            self.requirePosition()
            self.state = 92
            self.requireLevel()
            self.state = 93
            self.requireTechnicalSkills()
            self.state = 94
            self.requireEducation()
            self.state = 95
            self.requireExperience()
            self.state = 97
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 96
                self.requireLanguage()


            self.state = 99
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREFER_SECTION(self):
            return self.getToken(JDParser.PREFER_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDParser.RequireActivitesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_preferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreferences" ):
                listener.enterPreferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreferences" ):
                listener.exitPreferences(self)




    def preferences(self):

        localctx = JDParser.PreferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_preferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(JDParser.PREFER_SECTION)
            self.state = 102
            self.match(JDParser.OPEN_CURLY)
            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.TOOL_LABEL:
                self.state = 103
                self.requireTools()


            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.PROG_LANG_LABEL:
                self.state = 106
                self.requireProLang()


            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.FRAMEWORK_LABEL:
                self.state = 109
                self.requireFrameworks()


            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DATA_LABEL:
                self.state = 112
                self.requireDB()


            self.state = 116
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 115
                self.requireDegree()


            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 118
                self.requireGPA()


            self.state = 122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.EXP_LABEL:
                self.state = 121
                self.requireExperience()


            self.state = 125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 124
                self.requireLanguage()


            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.ACTIVITY_LABEL:
                self.state = 127
                self.requireActivites()


            self.state = 130
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirePositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION_LABEL(self):
            return self.getToken(JDParser.POSITION_LABEL, 0)

        def position(self):
            return self.getTypedRuleContext(JDParser.PositionContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requirePosition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirePosition" ):
                listener.enterRequirePosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirePosition" ):
                listener.exitRequirePosition(self)




    def requirePosition(self):

        localctx = JDParser.RequirePositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_requirePosition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(JDParser.POSITION_LABEL)
            self.state = 133
            self.position()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEVEL_LABEL(self):
            return self.getToken(JDParser.LEVEL_LABEL, 0)

        def level(self):
            return self.getTypedRuleContext(JDParser.LevelContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLevel" ):
                listener.enterRequireLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLevel" ):
                listener.exitRequireLevel(self)




    def requireLevel(self):

        localctx = JDParser.RequireLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_requireLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 135
            self.match(JDParser.LEVEL_LABEL)
            self.state = 136
            self.level()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireTechnicalSkillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACK_SECTION(self):
            return self.getToken(JDParser.STACK_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireTechnicalSkills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTechnicalSkills" ):
                listener.enterRequireTechnicalSkills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTechnicalSkills" ):
                listener.exitRequireTechnicalSkills(self)




    def requireTechnicalSkills(self):

        localctx = JDParser.RequireTechnicalSkillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_requireTechnicalSkills)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(JDParser.STACK_SECTION)
            self.state = 139
            self.match(JDParser.OPEN_CURLY)
            self.state = 140
            self.requireTools()
            self.state = 141
            self.requireProLang()
            self.state = 142
            self.requireFrameworks()
            self.state = 143
            self.requireDB()
            self.state = 144
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireToolsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOOL_LABEL(self):
            return self.getToken(JDParser.TOOL_LABEL, 0)

        def tool(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.ToolContext)
            else:
                return self.getTypedRuleContext(JDParser.ToolContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireTools

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTools" ):
                listener.enterRequireTools(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTools" ):
                listener.exitRequireTools(self)




    def requireTools(self):

        localctx = JDParser.RequireToolsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_requireTools)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(JDParser.TOOL_LABEL)
            self.state = 147
            self.tool()
            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 148
                self.match(JDParser.COMMA)
                self.state = 149
                self.tool()
                self.state = 154
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireProLangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROG_LANG_LABEL(self):
            return self.getToken(JDParser.PROG_LANG_LABEL, 0)

        def pro_lang(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.Pro_langContext)
            else:
                return self.getTypedRuleContext(JDParser.Pro_langContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireProLang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireProLang" ):
                listener.enterRequireProLang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireProLang" ):
                listener.exitRequireProLang(self)




    def requireProLang(self):

        localctx = JDParser.RequireProLangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_requireProLang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(JDParser.PROG_LANG_LABEL)
            self.state = 156
            self.pro_lang()
            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 157
                self.match(JDParser.COMMA)
                self.state = 158
                self.pro_lang()
                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireFrameworksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FRAMEWORK_LABEL(self):
            return self.getToken(JDParser.FRAMEWORK_LABEL, 0)

        def framework(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.FrameworkContext)
            else:
                return self.getTypedRuleContext(JDParser.FrameworkContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireFrameworks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireFrameworks" ):
                listener.enterRequireFrameworks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireFrameworks" ):
                listener.exitRequireFrameworks(self)




    def requireFrameworks(self):

        localctx = JDParser.RequireFrameworksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_requireFrameworks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(JDParser.FRAMEWORK_LABEL)
            self.state = 165
            self.framework()
            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 166
                self.match(JDParser.COMMA)
                self.state = 167
                self.framework()
                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDBContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA_LABEL(self):
            return self.getToken(JDParser.DATA_LABEL, 0)

        def db(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.DbContext)
            else:
                return self.getTypedRuleContext(JDParser.DbContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireDB

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDB" ):
                listener.enterRequireDB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDB" ):
                listener.exitRequireDB(self)




    def requireDB(self):

        localctx = JDParser.RequireDBContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_requireDB)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(JDParser.DATA_LABEL)
            self.state = 174
            self.db()
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 175
                self.match(JDParser.COMMA)
                self.state = 176
                self.db()
                self.state = 181
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireEducationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EDU_SECTION(self):
            return self.getToken(JDParser.EDU_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireMajor(self):
            return self.getTypedRuleContext(JDParser.RequireMajorContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireEducation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireEducation" ):
                listener.enterRequireEducation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireEducation" ):
                listener.exitRequireEducation(self)




    def requireEducation(self):

        localctx = JDParser.RequireEducationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_requireEducation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(JDParser.EDU_SECTION)
            self.state = 183
            self.match(JDParser.OPEN_CURLY)
            self.state = 184
            self.requireMajor()
            self.state = 186
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 185
                self.requireDegree()


            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 188
                self.requireGPA()


            self.state = 191
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireMajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAJOR_LABEL(self):
            return self.getToken(JDParser.MAJOR_LABEL, 0)

        def major(self):
            return self.getTypedRuleContext(JDParser.MajorContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireMajor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireMajor" ):
                listener.enterRequireMajor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireMajor" ):
                listener.exitRequireMajor(self)




    def requireMajor(self):

        localctx = JDParser.RequireMajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_requireMajor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(JDParser.MAJOR_LABEL)
            self.state = 194
            self.major()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEGREE_LABEL(self):
            return self.getToken(JDParser.DEGREE_LABEL, 0)

        def degree(self):
            return self.getTypedRuleContext(JDParser.DegreeContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireDegree

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDegree" ):
                listener.enterRequireDegree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDegree" ):
                listener.exitRequireDegree(self)




    def requireDegree(self):

        localctx = JDParser.RequireDegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_requireDegree)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(JDParser.DEGREE_LABEL)
            self.state = 197
            self.degree()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireGPAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GPA_LABEL(self):
            return self.getToken(JDParser.GPA_LABEL, 0)

        def COMPARATOR(self):
            return self.getToken(JDParser.COMPARATOR, 0)

        def FLOAT(self):
            return self.getToken(JDParser.FLOAT, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireGPA

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireGPA" ):
                listener.enterRequireGPA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireGPA" ):
                listener.exitRequireGPA(self)




    def requireGPA(self):

        localctx = JDParser.RequireGPAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_requireGPA)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(JDParser.GPA_LABEL)
            self.state = 200
            self.match(JDParser.COMPARATOR)
            self.state = 201
            self.match(JDParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANG_LABEL(self):
            return self.getToken(JDParser.LANG_LABEL, 0)

        def lang(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.LangContext)
            else:
                return self.getTypedRuleContext(JDParser.LangContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireLanguage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLanguage" ):
                listener.enterRequireLanguage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLanguage" ):
                listener.exitRequireLanguage(self)




    def requireLanguage(self):

        localctx = JDParser.RequireLanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_requireLanguage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(JDParser.LANG_LABEL)
            self.state = 204
            self.lang()
            self.state = 209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 205
                self.match(JDParser.COMMA)
                self.state = 206
                self.lang()
                self.state = 211
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireExperienceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXP_LABEL(self):
            return self.getToken(JDParser.EXP_LABEL, 0)

        def INT(self):
            return self.getToken(JDParser.INT, 0)

        def YEARS(self):
            return self.getToken(JDParser.YEARS, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireExperience

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireExperience" ):
                listener.enterRequireExperience(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireExperience" ):
                listener.exitRequireExperience(self)




    def requireExperience(self):

        localctx = JDParser.RequireExperienceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_requireExperience)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(JDParser.EXP_LABEL)
            self.state = 213
            self.match(JDParser.INT)
            self.state = 214
            self.match(JDParser.YEARS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireActivitesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTIVITY_LABEL(self):
            return self.getToken(JDParser.ACTIVITY_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireActivites

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireActivites" ):
                listener.enterRequireActivites(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireActivites" ):
                listener.exitRequireActivites(self)




    def requireActivites(self):

        localctx = JDParser.RequireActivitesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_requireActivites)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(JDParser.ACTIVITY_LABEL)
            self.state = 218 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 217
                self.match(JDParser.ID)
                self.state = 220 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)




    def position(self):

        localctx = JDParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_position)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__0) | (1 << JDParser.T__1) | (1 << JDParser.T__2) | (1 << JDParser.T__3) | (1 << JDParser.T__4) | (1 << JDParser.T__5) | (1 << JDParser.T__6) | (1 << JDParser.T__7) | (1 << JDParser.T__8) | (1 << JDParser.T__9) | (1 << JDParser.T__10) | (1 << JDParser.T__11) | (1 << JDParser.T__12) | (1 << JDParser.T__13) | (1 << JDParser.T__14) | (1 << JDParser.T__15) | (1 << JDParser.T__16) | (1 << JDParser.T__17) | (1 << JDParser.T__18) | (1 << JDParser.T__19) | (1 << JDParser.T__20) | (1 << JDParser.T__21) | (1 << JDParser.T__22) | (1 << JDParser.T__23) | (1 << JDParser.T__24) | (1 << JDParser.T__25))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_level

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLevel" ):
                listener.enterLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLevel" ):
                listener.exitLevel(self)




    def level(self):

        localctx = JDParser.LevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_level)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__26) | (1 << JDParser.T__27) | (1 << JDParser.T__28) | (1 << JDParser.T__29) | (1 << JDParser.T__30) | (1 << JDParser.T__31) | (1 << JDParser.T__32))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_degree

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDegree" ):
                listener.enterDegree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDegree" ):
                listener.exitDegree(self)




    def degree(self):

        localctx = JDParser.DegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_degree)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__33) | (1 << JDParser.T__34) | (1 << JDParser.T__35) | (1 << JDParser.T__36))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_major

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMajor" ):
                listener.enterMajor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMajor" ):
                listener.exitMajor(self)




    def major(self):

        localctx = JDParser.MajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_major)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__37) | (1 << JDParser.T__38) | (1 << JDParser.T__39) | (1 << JDParser.T__40) | (1 << JDParser.T__41) | (1 << JDParser.T__42) | (1 << JDParser.T__43))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_tool

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTool" ):
                listener.enterTool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTool" ):
                listener.exitTool(self)




    def tool(self):

        localctx = JDParser.ToolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tool)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            _la = self._input.LA(1)
            if not(((((_la - 45)) & ~0x3f) == 0 and ((1 << (_la - 45)) & ((1 << (JDParser.T__44 - 45)) | (1 << (JDParser.T__45 - 45)) | (1 << (JDParser.T__46 - 45)) | (1 << (JDParser.T__47 - 45)) | (1 << (JDParser.T__48 - 45)) | (1 << (JDParser.T__49 - 45)) | (1 << (JDParser.T__50 - 45)) | (1 << (JDParser.T__51 - 45)) | (1 << (JDParser.T__52 - 45)) | (1 << (JDParser.T__53 - 45)) | (1 << (JDParser.T__54 - 45)) | (1 << (JDParser.T__55 - 45)) | (1 << (JDParser.T__56 - 45)) | (1 << (JDParser.T__57 - 45)) | (1 << (JDParser.T__58 - 45)) | (1 << (JDParser.T__59 - 45)) | (1 << (JDParser.T__60 - 45)) | (1 << (JDParser.T__61 - 45)) | (1 << (JDParser.T__62 - 45)) | (1 << (JDParser.T__63 - 45)) | (1 << (JDParser.T__64 - 45)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pro_langContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_pro_lang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPro_lang" ):
                listener.enterPro_lang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPro_lang" ):
                listener.exitPro_lang(self)




    def pro_lang(self):

        localctx = JDParser.Pro_langContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_pro_lang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            _la = self._input.LA(1)
            if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (JDParser.T__65 - 66)) | (1 << (JDParser.T__66 - 66)) | (1 << (JDParser.T__67 - 66)) | (1 << (JDParser.T__68 - 66)) | (1 << (JDParser.T__69 - 66)) | (1 << (JDParser.T__70 - 66)) | (1 << (JDParser.T__71 - 66)) | (1 << (JDParser.T__72 - 66)) | (1 << (JDParser.T__73 - 66)) | (1 << (JDParser.T__74 - 66)) | (1 << (JDParser.T__75 - 66)) | (1 << (JDParser.T__76 - 66)) | (1 << (JDParser.T__77 - 66)) | (1 << (JDParser.T__78 - 66)) | (1 << (JDParser.T__79 - 66)) | (1 << (JDParser.T__80 - 66)) | (1 << (JDParser.T__81 - 66)) | (1 << (JDParser.T__82 - 66)) | (1 << (JDParser.T__83 - 66)) | (1 << (JDParser.T__84 - 66)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameworkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_framework

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFramework" ):
                listener.enterFramework(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFramework" ):
                listener.exitFramework(self)




    def framework(self):

        localctx = JDParser.FrameworkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_framework)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 234
            _la = self._input.LA(1)
            if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (JDParser.T__85 - 86)) | (1 << (JDParser.T__86 - 86)) | (1 << (JDParser.T__87 - 86)) | (1 << (JDParser.T__88 - 86)) | (1 << (JDParser.T__89 - 86)) | (1 << (JDParser.T__90 - 86)) | (1 << (JDParser.T__91 - 86)) | (1 << (JDParser.T__92 - 86)) | (1 << (JDParser.T__93 - 86)) | (1 << (JDParser.T__94 - 86)) | (1 << (JDParser.T__95 - 86)) | (1 << (JDParser.T__96 - 86)) | (1 << (JDParser.T__97 - 86)) | (1 << (JDParser.T__98 - 86)) | (1 << (JDParser.T__99 - 86)) | (1 << (JDParser.T__100 - 86)) | (1 << (JDParser.T__101 - 86)) | (1 << (JDParser.T__102 - 86)) | (1 << (JDParser.T__103 - 86)) | (1 << (JDParser.T__104 - 86)) | (1 << (JDParser.T__105 - 86)) | (1 << (JDParser.T__106 - 86)) | (1 << (JDParser.T__107 - 86)) | (1 << (JDParser.T__108 - 86)) | (1 << (JDParser.T__109 - 86)) | (1 << (JDParser.T__110 - 86)) | (1 << (JDParser.T__111 - 86)) | (1 << (JDParser.T__112 - 86)) | (1 << (JDParser.T__113 - 86)) | (1 << (JDParser.T__114 - 86)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_db

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDb" ):
                listener.enterDb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDb" ):
                listener.exitDb(self)




    def db(self):

        localctx = JDParser.DbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_db)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            _la = self._input.LA(1)
            if not(((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (JDParser.T__115 - 116)) | (1 << (JDParser.T__116 - 116)) | (1 << (JDParser.T__117 - 116)) | (1 << (JDParser.T__118 - 116)) | (1 << (JDParser.T__119 - 116)) | (1 << (JDParser.T__120 - 116)) | (1 << (JDParser.T__121 - 116)) | (1 << (JDParser.T__122 - 116)) | (1 << (JDParser.T__123 - 116)) | (1 << (JDParser.T__124 - 116)) | (1 << (JDParser.T__125 - 116)) | (1 << (JDParser.T__126 - 116)) | (1 << (JDParser.T__127 - 116)) | (1 << (JDParser.T__128 - 116)) | (1 << (JDParser.T__129 - 116)) | (1 << (JDParser.T__130 - 116)) | (1 << (JDParser.T__131 - 116)) | (1 << (JDParser.T__132 - 116)) | (1 << (JDParser.T__133 - 116)) | (1 << (JDParser.T__134 - 116)) | (1 << (JDParser.T__135 - 116)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_lang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLang" ):
                listener.enterLang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLang" ):
                listener.exitLang(self)




    def lang(self):

        localctx = JDParser.LangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_lang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            _la = self._input.LA(1)
            if not(((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & ((1 << (JDParser.T__136 - 137)) | (1 << (JDParser.T__137 - 137)) | (1 << (JDParser.T__138 - 137)) | (1 << (JDParser.T__139 - 137)) | (1 << (JDParser.T__140 - 137)) | (1 << (JDParser.T__141 - 137)) | (1 << (JDParser.T__142 - 137)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





