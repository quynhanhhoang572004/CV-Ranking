# Generated from JD.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00ab")
        buf.write("\u00d2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\3\2\3\2\5\29\n\2\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\5\3C\n\3\3\3\3\3\3\4\3\4\3\4\5\4")
        buf.write("J\n\4\3\4\5\4M\n\4\3\4\5\4P\n\4\3\4\5\4S\n\4\3\4\5\4V")
        buf.write("\n\4\3\4\5\4Y\n\4\3\4\5\4\\\n\4\3\4\5\4_\n\4\3\4\5\4b")
        buf.write("\n\4\3\4\3\4\3\5\3\5\3\5\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\7\bx\n\b\f\b\16\b{\13\b")
        buf.write("\3\t\3\t\3\t\3\t\7\t\u0081\n\t\f\t\16\t\u0084\13\t\3\n")
        buf.write("\3\n\3\n\3\n\7\n\u008a\n\n\f\n\16\n\u008d\13\n\3\13\3")
        buf.write("\13\3\13\3\13\7\13\u0093\n\13\f\13\16\13\u0096\13\13\3")
        buf.write("\f\3\f\3\f\3\f\5\f\u009c\n\f\3\f\5\f\u009f\n\f\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\20\3")
        buf.write("\20\3\20\3\20\7\20\u00b1\n\20\f\20\16\20\u00b4\13\20\3")
        buf.write("\21\3\21\3\21\3\21\3\22\3\22\6\22\u00bc\n\22\r\22\16\22")
        buf.write("\u00bd\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3")
        buf.write("\27\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\33\2\2\34")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\2\13\3\2\3\34\3\2\35#\3\2$\'\3\2(.\3\2/C\3\2DW\3\2")
        buf.write("Xu\3\2v\u008a\3\2\u008b\u0091\2\u00ca\2\66\3\2\2\2\4:")
        buf.write("\3\2\2\2\6F\3\2\2\2\be\3\2\2\2\nh\3\2\2\2\fk\3\2\2\2\16")
        buf.write("s\3\2\2\2\20|\3\2\2\2\22\u0085\3\2\2\2\24\u008e\3\2\2")
        buf.write("\2\26\u0097\3\2\2\2\30\u00a2\3\2\2\2\32\u00a5\3\2\2\2")
        buf.write("\34\u00a8\3\2\2\2\36\u00ac\3\2\2\2 \u00b5\3\2\2\2\"\u00b9")
        buf.write("\3\2\2\2$\u00bf\3\2\2\2&\u00c1\3\2\2\2(\u00c3\3\2\2\2")
        buf.write("*\u00c5\3\2\2\2,\u00c7\3\2\2\2.\u00c9\3\2\2\2\60\u00cb")
        buf.write("\3\2\2\2\62\u00cd\3\2\2\2\64\u00cf\3\2\2\2\668\5\4\3\2")
        buf.write("\679\5\6\4\28\67\3\2\2\289\3\2\2\29\3\3\2\2\2:;\7\u0092")
        buf.write("\2\2;<\7\u00a4\2\2<=\5\b\5\2=>\5\n\6\2>?\5\f\7\2?@\5\26")
        buf.write("\f\2@B\5 \21\2AC\5\36\20\2BA\3\2\2\2BC\3\2\2\2CD\3\2\2")
        buf.write("\2DE\7\u00a5\2\2E\5\3\2\2\2FG\7\u0093\2\2GI\7\u00a4\2")
        buf.write("\2HJ\5\16\b\2IH\3\2\2\2IJ\3\2\2\2JL\3\2\2\2KM\5\20\t\2")
        buf.write("LK\3\2\2\2LM\3\2\2\2MO\3\2\2\2NP\5\22\n\2ON\3\2\2\2OP")
        buf.write("\3\2\2\2PR\3\2\2\2QS\5\24\13\2RQ\3\2\2\2RS\3\2\2\2SU\3")
        buf.write("\2\2\2TV\5\32\16\2UT\3\2\2\2UV\3\2\2\2VX\3\2\2\2WY\5\34")
        buf.write("\17\2XW\3\2\2\2XY\3\2\2\2Y[\3\2\2\2Z\\\5 \21\2[Z\3\2\2")
        buf.write("\2[\\\3\2\2\2\\^\3\2\2\2]_\5\36\20\2^]\3\2\2\2^_\3\2\2")
        buf.write("\2_a\3\2\2\2`b\5\"\22\2a`\3\2\2\2ab\3\2\2\2bc\3\2\2\2")
        buf.write("cd\7\u00a5\2\2d\7\3\2\2\2ef\7\u0094\2\2fg\5$\23\2g\t\3")
        buf.write("\2\2\2hi\7\u0095\2\2ij\5&\24\2j\13\3\2\2\2kl\7\u0096\2")
        buf.write("\2lm\7\u00a4\2\2mn\5\16\b\2no\5\20\t\2op\5\22\n\2pq\5")
        buf.write("\24\13\2qr\7\u00a5\2\2r\r\3\2\2\2st\7\u009c\2\2ty\5,\27")
        buf.write("\2uv\7\u00a6\2\2vx\5,\27\2wu\3\2\2\2x{\3\2\2\2yw\3\2\2")
        buf.write("\2yz\3\2\2\2z\17\3\2\2\2{y\3\2\2\2|}\7\u009d\2\2}\u0082")
        buf.write("\5.\30\2~\177\7\u00a6\2\2\177\u0081\5.\30\2\u0080~\3\2")
        buf.write("\2\2\u0081\u0084\3\2\2\2\u0082\u0080\3\2\2\2\u0082\u0083")
        buf.write("\3\2\2\2\u0083\21\3\2\2\2\u0084\u0082\3\2\2\2\u0085\u0086")
        buf.write("\7\u009e\2\2\u0086\u008b\5\60\31\2\u0087\u0088\7\u00a6")
        buf.write("\2\2\u0088\u008a\5\60\31\2\u0089\u0087\3\2\2\2\u008a\u008d")
        buf.write("\3\2\2\2\u008b\u0089\3\2\2\2\u008b\u008c\3\2\2\2\u008c")
        buf.write("\23\3\2\2\2\u008d\u008b\3\2\2\2\u008e\u008f\7\u009f\2")
        buf.write("\2\u008f\u0094\5\62\32\2\u0090\u0091\7\u00a6\2\2\u0091")
        buf.write("\u0093\5\62\32\2\u0092\u0090\3\2\2\2\u0093\u0096\3\2\2")
        buf.write("\2\u0094\u0092\3\2\2\2\u0094\u0095\3\2\2\2\u0095\25\3")
        buf.write("\2\2\2\u0096\u0094\3\2\2\2\u0097\u0098\7\u0097\2\2\u0098")
        buf.write("\u0099\7\u00a4\2\2\u0099\u009b\5\30\r\2\u009a\u009c\5")
        buf.write("\32\16\2\u009b\u009a\3\2\2\2\u009b\u009c\3\2\2\2\u009c")
        buf.write("\u009e\3\2\2\2\u009d\u009f\5\34\17\2\u009e\u009d\3\2\2")
        buf.write("\2\u009e\u009f\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a1")
        buf.write("\7\u00a5\2\2\u00a1\27\3\2\2\2\u00a2\u00a3\7\u00a0\2\2")
        buf.write("\u00a3\u00a4\5*\26\2\u00a4\31\3\2\2\2\u00a5\u00a6\7\u00a1")
        buf.write("\2\2\u00a6\u00a7\5(\25\2\u00a7\33\3\2\2\2\u00a8\u00a9")
        buf.write("\7\u00a2\2\2\u00a9\u00aa\7\u00a7\2\2\u00aa\u00ab\7\u00a9")
        buf.write("\2\2\u00ab\35\3\2\2\2\u00ac\u00ad\7\u0098\2\2\u00ad\u00b2")
        buf.write("\5\64\33\2\u00ae\u00af\7\u00a6\2\2\u00af\u00b1\5\64\33")
        buf.write("\2\u00b0\u00ae\3\2\2\2\u00b1\u00b4\3\2\2\2\u00b2\u00b0")
        buf.write("\3\2\2\2\u00b2\u00b3\3\2\2\2\u00b3\37\3\2\2\2\u00b4\u00b2")
        buf.write("\3\2\2\2\u00b5\u00b6\7\u009a\2\2\u00b6\u00b7\7\u00a8\2")
        buf.write("\2\u00b7\u00b8\7\u00a3\2\2\u00b8!\3\2\2\2\u00b9\u00bb")
        buf.write("\7\u0099\2\2\u00ba\u00bc\7\u00aa\2\2\u00bb\u00ba\3\2\2")
        buf.write("\2\u00bc\u00bd\3\2\2\2\u00bd\u00bb\3\2\2\2\u00bd\u00be")
        buf.write("\3\2\2\2\u00be#\3\2\2\2\u00bf\u00c0\t\2\2\2\u00c0%\3\2")
        buf.write("\2\2\u00c1\u00c2\t\3\2\2\u00c2\'\3\2\2\2\u00c3\u00c4\t")
        buf.write("\4\2\2\u00c4)\3\2\2\2\u00c5\u00c6\t\5\2\2\u00c6+\3\2\2")
        buf.write("\2\u00c7\u00c8\t\6\2\2\u00c8-\3\2\2\2\u00c9\u00ca\t\7")
        buf.write("\2\2\u00ca/\3\2\2\2\u00cb\u00cc\t\b\2\2\u00cc\61\3\2\2")
        buf.write("\2\u00cd\u00ce\t\t\2\2\u00ce\63\3\2\2\2\u00cf\u00d0\t")
        buf.write("\n\2\2\u00d0\65\3\2\2\2\258BILORUX[^ay\u0082\u008b\u0094")
        buf.write("\u009b\u009e\u00b2\u00bd")
        return buf.getvalue()


class JDParser ( Parser ):

    grammarFileName = "JD.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'frontend developer'", "'backend developer'", 
                     "'full-stack developer'", "'software engineer'", "'ai engineer'", 
                     "'ml engineer'", "'data scientist'", "'data engineer'", 
                     "'data analyst'", "'qa/qc engineer'", "'tester'", "'security engineer'", 
                     "'devops engineer'", "'cloud engineer'", "'network engineer'", 
                     "'embedded engineer'", "'mobile developer'", "'android developer'", 
                     "'ios developer'", "'solution architect'", "'technical lead'", 
                     "'product manager'", "'scrum master'", "'game developer'", 
                     "'blockchain developer'", "'research engineer'", "'intern'", 
                     "'fresher'", "'junior'", "'medium'", "'senior'", "'director'", 
                     "'manager'", "'bachelor'", "'engineering'", "'master'", 
                     "'phd'", "'computer science'", "'computer engineering'", 
                     "'network engineering'", "'data science'", "'artificial intelligence'", 
                     "'cybersecurity'", "'information systems'", "'git'", 
                     "'docker'", "'kubernetes'", "'jenkins'", "'jira'", 
                     "'postman'", "'webpack'", "'npm'", "'yarn'", "'vscode'", 
                     "'intellij'", "'eclipse'", "'figma'", "'trello'", "'slack'", 
                     "'notion'", "'aws cli'", "'gcp sdk'", "'azure cli'", 
                     "'terraform'", "'github actions'", "'python'", "'java'", 
                     "'c'", "'c++'", "'c#'", "'go'", "'rust'", "'javascript'", 
                     "'typescript'", "'ruby'", "'php'", "'swift'", "'kotlin'", 
                     "'scala'", "'r'", "'matlab'", "'bash'", "'sql'", "'haskell'", 
                     "'perl'", "'pytorch'", "'tensorflow'", "'keras'", "'scikit-learn'", 
                     "'xgboost'", "'lightgbm'", "'opencv'", "'flask'", "'django'", 
                     "'spring'", "'express'", "'fastapi'", "'next.js'", 
                     "'nuxt.js'", "'react'", "'vue'", "'angular'", "'bootstrap'", 
                     "'laravel'", "'.net'", "'asp.net'", "'electron'", "'flutter'", 
                     "'react native'", "'node.js'", "'nestjs'", "'redux'", 
                     "'mui'", "'tailwindcss'", "'springboot'", "'mysql'", 
                     "'postgresql'", "'sqlite'", "'mongodb'", "'redis'", 
                     "'mariadb'", "'oracle'", "'sql server'", "'dynamodb'", 
                     "'cassandra'", "'elasticsearch'", "'aws'", "'azure'", 
                     "'gcp'", "'google cloud'", "'amazon web services'", 
                     "'firebase'", "'heroku'", "'digitalocean'", "'vercel'", 
                     "'netlify'", "'english'", "'japanese'", "'chinese'", 
                     "'korean'", "'german'", "'portugeese'", "'french'", 
                     "'REQUIREMENTS'", "'PREFERENCES'", "'position:'", "'level:'", 
                     "'stack'", "'education'", "'language:'", "'activities:'", 
                     "'experience:'", "'references:'", "'tools:'", "'programming languages:'", 
                     "'framework libraries:'", "'databases cloud services:'", 
                     "'major:'", "'degree:'", "'gpa:'", "'years'", "'{'", 
                     "'}'", "','" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "REQUIRE_SECTION", "PREFER_SECTION", "POSITION_LABEL", 
                      "LEVEL_LABEL", "STACK_SECTION", "EDU_SECTION", "LANG_LABEL", 
                      "ACTIVITY_LABEL", "EXP_LABEL", "REF_LABEL", "TOOL_LABEL", 
                      "PROG_LANG_LABEL", "FRAMEWORK_LABEL", "DATA_LABEL", 
                      "MAJOR_LABEL", "DEGREE_LABEL", "GPA_LABEL", "YEARS", 
                      "OPEN_CURLY", "CLOSE_CURLY", "COMMA", "COMPARATOR", 
                      "INT", "FLOAT", "ID", "WS" ]

    RULE_program = 0
    RULE_requirements = 1
    RULE_preferences = 2
    RULE_requirePosition = 3
    RULE_requireLevel = 4
    RULE_requireTechnicalSkills = 5
    RULE_requireTools = 6
    RULE_requireProLang = 7
    RULE_requireFrameworks = 8
    RULE_requireDB = 9
    RULE_requireEducation = 10
    RULE_requireMajor = 11
    RULE_requireDegree = 12
    RULE_requireGPA = 13
    RULE_requireLanguage = 14
    RULE_requireExperience = 15
    RULE_requireActivites = 16
    RULE_position = 17
    RULE_level = 18
    RULE_degree = 19
    RULE_major = 20
    RULE_tool = 21
    RULE_pro_lang = 22
    RULE_framework = 23
    RULE_db = 24
    RULE_lang = 25

    ruleNames =  [ "program", "requirements", "preferences", "requirePosition", 
                   "requireLevel", "requireTechnicalSkills", "requireTools", 
                   "requireProLang", "requireFrameworks", "requireDB", "requireEducation", 
                   "requireMajor", "requireDegree", "requireGPA", "requireLanguage", 
                   "requireExperience", "requireActivites", "position", 
                   "level", "degree", "major", "tool", "pro_lang", "framework", 
                   "db", "lang" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    T__102=103
    T__103=104
    T__104=105
    T__105=106
    T__106=107
    T__107=108
    T__108=109
    T__109=110
    T__110=111
    T__111=112
    T__112=113
    T__113=114
    T__114=115
    T__115=116
    T__116=117
    T__117=118
    T__118=119
    T__119=120
    T__120=121
    T__121=122
    T__122=123
    T__123=124
    T__124=125
    T__125=126
    T__126=127
    T__127=128
    T__128=129
    T__129=130
    T__130=131
    T__131=132
    T__132=133
    T__133=134
    T__134=135
    T__135=136
    T__136=137
    T__137=138
    T__138=139
    T__139=140
    T__140=141
    T__141=142
    T__142=143
    REQUIRE_SECTION=144
    PREFER_SECTION=145
    POSITION_LABEL=146
    LEVEL_LABEL=147
    STACK_SECTION=148
    EDU_SECTION=149
    LANG_LABEL=150
    ACTIVITY_LABEL=151
    EXP_LABEL=152
    REF_LABEL=153
    TOOL_LABEL=154
    PROG_LANG_LABEL=155
    FRAMEWORK_LABEL=156
    DATA_LABEL=157
    MAJOR_LABEL=158
    DEGREE_LABEL=159
    GPA_LABEL=160
    YEARS=161
    OPEN_CURLY=162
    CLOSE_CURLY=163
    COMMA=164
    COMPARATOR=165
    INT=166
    FLOAT=167
    ID=168
    WS=169

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def requirements(self):
            return self.getTypedRuleContext(JDParser.RequirementsContext,0)


        def preferences(self):
            return self.getTypedRuleContext(JDParser.PreferencesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = JDParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.requirements()
            self.state = 54
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.PREFER_SECTION:
                self.state = 53
                self.preferences()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRE_SECTION(self):
            return self.getToken(JDParser.REQUIRE_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requirePosition(self):
            return self.getTypedRuleContext(JDParser.RequirePositionContext,0)


        def requireLevel(self):
            return self.getTypedRuleContext(JDParser.RequireLevelContext,0)


        def requireTechnicalSkills(self):
            return self.getTypedRuleContext(JDParser.RequireTechnicalSkillsContext,0)


        def requireEducation(self):
            return self.getTypedRuleContext(JDParser.RequireEducationContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requirements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirements" ):
                listener.enterRequirements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirements" ):
                listener.exitRequirements(self)




    def requirements(self):

        localctx = JDParser.RequirementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_requirements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.match(JDParser.REQUIRE_SECTION)
            self.state = 57
            self.match(JDParser.OPEN_CURLY)
            self.state = 58
            self.requirePosition()
            self.state = 59
            self.requireLevel()
            self.state = 60
            self.requireTechnicalSkills()
            self.state = 61
            self.requireEducation()
            self.state = 62
            self.requireExperience()
            self.state = 64
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 63
                self.requireLanguage()


            self.state = 66
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreferencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREFER_SECTION(self):
            return self.getToken(JDParser.PREFER_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def requireExperience(self):
            return self.getTypedRuleContext(JDParser.RequireExperienceContext,0)


        def requireLanguage(self):
            return self.getTypedRuleContext(JDParser.RequireLanguageContext,0)


        def requireActivites(self):
            return self.getTypedRuleContext(JDParser.RequireActivitesContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_preferences

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreferences" ):
                listener.enterPreferences(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreferences" ):
                listener.exitPreferences(self)




    def preferences(self):

        localctx = JDParser.PreferencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_preferences)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 68
            self.match(JDParser.PREFER_SECTION)
            self.state = 69
            self.match(JDParser.OPEN_CURLY)
            self.state = 71
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.TOOL_LABEL:
                self.state = 70
                self.requireTools()


            self.state = 74
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.PROG_LANG_LABEL:
                self.state = 73
                self.requireProLang()


            self.state = 77
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.FRAMEWORK_LABEL:
                self.state = 76
                self.requireFrameworks()


            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DATA_LABEL:
                self.state = 79
                self.requireDB()


            self.state = 83
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 82
                self.requireDegree()


            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 85
                self.requireGPA()


            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.EXP_LABEL:
                self.state = 88
                self.requireExperience()


            self.state = 92
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.LANG_LABEL:
                self.state = 91
                self.requireLanguage()


            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.ACTIVITY_LABEL:
                self.state = 94
                self.requireActivites()


            self.state = 97
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequirePositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION_LABEL(self):
            return self.getToken(JDParser.POSITION_LABEL, 0)

        def position(self):
            return self.getTypedRuleContext(JDParser.PositionContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requirePosition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequirePosition" ):
                listener.enterRequirePosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequirePosition" ):
                listener.exitRequirePosition(self)




    def requirePosition(self):

        localctx = JDParser.RequirePositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_requirePosition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(JDParser.POSITION_LABEL)
            self.state = 100
            self.position()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEVEL_LABEL(self):
            return self.getToken(JDParser.LEVEL_LABEL, 0)

        def level(self):
            return self.getTypedRuleContext(JDParser.LevelContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireLevel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLevel" ):
                listener.enterRequireLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLevel" ):
                listener.exitRequireLevel(self)




    def requireLevel(self):

        localctx = JDParser.RequireLevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_requireLevel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(JDParser.LEVEL_LABEL)
            self.state = 103
            self.level()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireTechnicalSkillsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STACK_SECTION(self):
            return self.getToken(JDParser.STACK_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireTools(self):
            return self.getTypedRuleContext(JDParser.RequireToolsContext,0)


        def requireProLang(self):
            return self.getTypedRuleContext(JDParser.RequireProLangContext,0)


        def requireFrameworks(self):
            return self.getTypedRuleContext(JDParser.RequireFrameworksContext,0)


        def requireDB(self):
            return self.getTypedRuleContext(JDParser.RequireDBContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireTechnicalSkills

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTechnicalSkills" ):
                listener.enterRequireTechnicalSkills(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTechnicalSkills" ):
                listener.exitRequireTechnicalSkills(self)




    def requireTechnicalSkills(self):

        localctx = JDParser.RequireTechnicalSkillsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_requireTechnicalSkills)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.match(JDParser.STACK_SECTION)
            self.state = 106
            self.match(JDParser.OPEN_CURLY)
            self.state = 107
            self.requireTools()
            self.state = 108
            self.requireProLang()
            self.state = 109
            self.requireFrameworks()
            self.state = 110
            self.requireDB()
            self.state = 111
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireToolsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOOL_LABEL(self):
            return self.getToken(JDParser.TOOL_LABEL, 0)

        def tool(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.ToolContext)
            else:
                return self.getTypedRuleContext(JDParser.ToolContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireTools

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireTools" ):
                listener.enterRequireTools(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireTools" ):
                listener.exitRequireTools(self)




    def requireTools(self):

        localctx = JDParser.RequireToolsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_requireTools)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.match(JDParser.TOOL_LABEL)
            self.state = 114
            self.tool()
            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 115
                self.match(JDParser.COMMA)
                self.state = 116
                self.tool()
                self.state = 121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireProLangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROG_LANG_LABEL(self):
            return self.getToken(JDParser.PROG_LANG_LABEL, 0)

        def pro_lang(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.Pro_langContext)
            else:
                return self.getTypedRuleContext(JDParser.Pro_langContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireProLang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireProLang" ):
                listener.enterRequireProLang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireProLang" ):
                listener.exitRequireProLang(self)




    def requireProLang(self):

        localctx = JDParser.RequireProLangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_requireProLang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(JDParser.PROG_LANG_LABEL)
            self.state = 123
            self.pro_lang()
            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 124
                self.match(JDParser.COMMA)
                self.state = 125
                self.pro_lang()
                self.state = 130
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireFrameworksContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FRAMEWORK_LABEL(self):
            return self.getToken(JDParser.FRAMEWORK_LABEL, 0)

        def framework(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.FrameworkContext)
            else:
                return self.getTypedRuleContext(JDParser.FrameworkContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireFrameworks

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireFrameworks" ):
                listener.enterRequireFrameworks(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireFrameworks" ):
                listener.exitRequireFrameworks(self)




    def requireFrameworks(self):

        localctx = JDParser.RequireFrameworksContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_requireFrameworks)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(JDParser.FRAMEWORK_LABEL)
            self.state = 132
            self.framework()
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 133
                self.match(JDParser.COMMA)
                self.state = 134
                self.framework()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDBContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA_LABEL(self):
            return self.getToken(JDParser.DATA_LABEL, 0)

        def db(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.DbContext)
            else:
                return self.getTypedRuleContext(JDParser.DbContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireDB

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDB" ):
                listener.enterRequireDB(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDB" ):
                listener.exitRequireDB(self)




    def requireDB(self):

        localctx = JDParser.RequireDBContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_requireDB)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(JDParser.DATA_LABEL)
            self.state = 141
            self.db()
            self.state = 146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 142
                self.match(JDParser.COMMA)
                self.state = 143
                self.db()
                self.state = 148
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireEducationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EDU_SECTION(self):
            return self.getToken(JDParser.EDU_SECTION, 0)

        def OPEN_CURLY(self):
            return self.getToken(JDParser.OPEN_CURLY, 0)

        def requireMajor(self):
            return self.getTypedRuleContext(JDParser.RequireMajorContext,0)


        def CLOSE_CURLY(self):
            return self.getToken(JDParser.CLOSE_CURLY, 0)

        def requireDegree(self):
            return self.getTypedRuleContext(JDParser.RequireDegreeContext,0)


        def requireGPA(self):
            return self.getTypedRuleContext(JDParser.RequireGPAContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireEducation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireEducation" ):
                listener.enterRequireEducation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireEducation" ):
                listener.exitRequireEducation(self)




    def requireEducation(self):

        localctx = JDParser.RequireEducationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_requireEducation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.match(JDParser.EDU_SECTION)
            self.state = 150
            self.match(JDParser.OPEN_CURLY)
            self.state = 151
            self.requireMajor()
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.DEGREE_LABEL:
                self.state = 152
                self.requireDegree()


            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==JDParser.GPA_LABEL:
                self.state = 155
                self.requireGPA()


            self.state = 158
            self.match(JDParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireMajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAJOR_LABEL(self):
            return self.getToken(JDParser.MAJOR_LABEL, 0)

        def major(self):
            return self.getTypedRuleContext(JDParser.MajorContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireMajor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireMajor" ):
                listener.enterRequireMajor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireMajor" ):
                listener.exitRequireMajor(self)




    def requireMajor(self):

        localctx = JDParser.RequireMajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_requireMajor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(JDParser.MAJOR_LABEL)
            self.state = 161
            self.major()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireDegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEGREE_LABEL(self):
            return self.getToken(JDParser.DEGREE_LABEL, 0)

        def degree(self):
            return self.getTypedRuleContext(JDParser.DegreeContext,0)


        def getRuleIndex(self):
            return JDParser.RULE_requireDegree

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireDegree" ):
                listener.enterRequireDegree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireDegree" ):
                listener.exitRequireDegree(self)




    def requireDegree(self):

        localctx = JDParser.RequireDegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_requireDegree)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(JDParser.DEGREE_LABEL)
            self.state = 164
            self.degree()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireGPAContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GPA_LABEL(self):
            return self.getToken(JDParser.GPA_LABEL, 0)

        def COMPARATOR(self):
            return self.getToken(JDParser.COMPARATOR, 0)

        def FLOAT(self):
            return self.getToken(JDParser.FLOAT, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireGPA

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireGPA" ):
                listener.enterRequireGPA(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireGPA" ):
                listener.exitRequireGPA(self)




    def requireGPA(self):

        localctx = JDParser.RequireGPAContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_requireGPA)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.match(JDParser.GPA_LABEL)
            self.state = 167
            self.match(JDParser.COMPARATOR)
            self.state = 168
            self.match(JDParser.FLOAT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireLanguageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LANG_LABEL(self):
            return self.getToken(JDParser.LANG_LABEL, 0)

        def lang(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(JDParser.LangContext)
            else:
                return self.getTypedRuleContext(JDParser.LangContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.COMMA)
            else:
                return self.getToken(JDParser.COMMA, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireLanguage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireLanguage" ):
                listener.enterRequireLanguage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireLanguage" ):
                listener.exitRequireLanguage(self)




    def requireLanguage(self):

        localctx = JDParser.RequireLanguageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_requireLanguage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(JDParser.LANG_LABEL)
            self.state = 171
            self.lang()
            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==JDParser.COMMA:
                self.state = 172
                self.match(JDParser.COMMA)
                self.state = 173
                self.lang()
                self.state = 178
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireExperienceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXP_LABEL(self):
            return self.getToken(JDParser.EXP_LABEL, 0)

        def INT(self):
            return self.getToken(JDParser.INT, 0)

        def YEARS(self):
            return self.getToken(JDParser.YEARS, 0)

        def getRuleIndex(self):
            return JDParser.RULE_requireExperience

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireExperience" ):
                listener.enterRequireExperience(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireExperience" ):
                listener.exitRequireExperience(self)




    def requireExperience(self):

        localctx = JDParser.RequireExperienceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_requireExperience)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(JDParser.EXP_LABEL)
            self.state = 180
            self.match(JDParser.INT)
            self.state = 181
            self.match(JDParser.YEARS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequireActivitesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACTIVITY_LABEL(self):
            return self.getToken(JDParser.ACTIVITY_LABEL, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(JDParser.ID)
            else:
                return self.getToken(JDParser.ID, i)

        def getRuleIndex(self):
            return JDParser.RULE_requireActivites

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequireActivites" ):
                listener.enterRequireActivites(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequireActivites" ):
                listener.exitRequireActivites(self)




    def requireActivites(self):

        localctx = JDParser.RequireActivitesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_requireActivites)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(JDParser.ACTIVITY_LABEL)
            self.state = 185 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 184
                self.match(JDParser.ID)
                self.state = 187 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==JDParser.ID):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_position

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)




    def position(self):

        localctx = JDParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_position)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__0) | (1 << JDParser.T__1) | (1 << JDParser.T__2) | (1 << JDParser.T__3) | (1 << JDParser.T__4) | (1 << JDParser.T__5) | (1 << JDParser.T__6) | (1 << JDParser.T__7) | (1 << JDParser.T__8) | (1 << JDParser.T__9) | (1 << JDParser.T__10) | (1 << JDParser.T__11) | (1 << JDParser.T__12) | (1 << JDParser.T__13) | (1 << JDParser.T__14) | (1 << JDParser.T__15) | (1 << JDParser.T__16) | (1 << JDParser.T__17) | (1 << JDParser.T__18) | (1 << JDParser.T__19) | (1 << JDParser.T__20) | (1 << JDParser.T__21) | (1 << JDParser.T__22) | (1 << JDParser.T__23) | (1 << JDParser.T__24) | (1 << JDParser.T__25))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LevelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_level

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLevel" ):
                listener.enterLevel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLevel" ):
                listener.exitLevel(self)




    def level(self):

        localctx = JDParser.LevelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_level)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__26) | (1 << JDParser.T__27) | (1 << JDParser.T__28) | (1 << JDParser.T__29) | (1 << JDParser.T__30) | (1 << JDParser.T__31) | (1 << JDParser.T__32))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DegreeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_degree

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDegree" ):
                listener.enterDegree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDegree" ):
                listener.exitDegree(self)




    def degree(self):

        localctx = JDParser.DegreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_degree)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__33) | (1 << JDParser.T__34) | (1 << JDParser.T__35) | (1 << JDParser.T__36))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MajorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_major

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMajor" ):
                listener.enterMajor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMajor" ):
                listener.exitMajor(self)




    def major(self):

        localctx = JDParser.MajorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_major)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << JDParser.T__37) | (1 << JDParser.T__38) | (1 << JDParser.T__39) | (1 << JDParser.T__40) | (1 << JDParser.T__41) | (1 << JDParser.T__42) | (1 << JDParser.T__43))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ToolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_tool

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTool" ):
                listener.enterTool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTool" ):
                listener.exitTool(self)




    def tool(self):

        localctx = JDParser.ToolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_tool)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            _la = self._input.LA(1)
            if not(((((_la - 45)) & ~0x3f) == 0 and ((1 << (_la - 45)) & ((1 << (JDParser.T__44 - 45)) | (1 << (JDParser.T__45 - 45)) | (1 << (JDParser.T__46 - 45)) | (1 << (JDParser.T__47 - 45)) | (1 << (JDParser.T__48 - 45)) | (1 << (JDParser.T__49 - 45)) | (1 << (JDParser.T__50 - 45)) | (1 << (JDParser.T__51 - 45)) | (1 << (JDParser.T__52 - 45)) | (1 << (JDParser.T__53 - 45)) | (1 << (JDParser.T__54 - 45)) | (1 << (JDParser.T__55 - 45)) | (1 << (JDParser.T__56 - 45)) | (1 << (JDParser.T__57 - 45)) | (1 << (JDParser.T__58 - 45)) | (1 << (JDParser.T__59 - 45)) | (1 << (JDParser.T__60 - 45)) | (1 << (JDParser.T__61 - 45)) | (1 << (JDParser.T__62 - 45)) | (1 << (JDParser.T__63 - 45)) | (1 << (JDParser.T__64 - 45)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pro_langContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_pro_lang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPro_lang" ):
                listener.enterPro_lang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPro_lang" ):
                listener.exitPro_lang(self)




    def pro_lang(self):

        localctx = JDParser.Pro_langContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_pro_lang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            _la = self._input.LA(1)
            if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (JDParser.T__65 - 66)) | (1 << (JDParser.T__66 - 66)) | (1 << (JDParser.T__67 - 66)) | (1 << (JDParser.T__68 - 66)) | (1 << (JDParser.T__69 - 66)) | (1 << (JDParser.T__70 - 66)) | (1 << (JDParser.T__71 - 66)) | (1 << (JDParser.T__72 - 66)) | (1 << (JDParser.T__73 - 66)) | (1 << (JDParser.T__74 - 66)) | (1 << (JDParser.T__75 - 66)) | (1 << (JDParser.T__76 - 66)) | (1 << (JDParser.T__77 - 66)) | (1 << (JDParser.T__78 - 66)) | (1 << (JDParser.T__79 - 66)) | (1 << (JDParser.T__80 - 66)) | (1 << (JDParser.T__81 - 66)) | (1 << (JDParser.T__82 - 66)) | (1 << (JDParser.T__83 - 66)) | (1 << (JDParser.T__84 - 66)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameworkContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_framework

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFramework" ):
                listener.enterFramework(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFramework" ):
                listener.exitFramework(self)




    def framework(self):

        localctx = JDParser.FrameworkContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_framework)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            _la = self._input.LA(1)
            if not(((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (JDParser.T__85 - 86)) | (1 << (JDParser.T__86 - 86)) | (1 << (JDParser.T__87 - 86)) | (1 << (JDParser.T__88 - 86)) | (1 << (JDParser.T__89 - 86)) | (1 << (JDParser.T__90 - 86)) | (1 << (JDParser.T__91 - 86)) | (1 << (JDParser.T__92 - 86)) | (1 << (JDParser.T__93 - 86)) | (1 << (JDParser.T__94 - 86)) | (1 << (JDParser.T__95 - 86)) | (1 << (JDParser.T__96 - 86)) | (1 << (JDParser.T__97 - 86)) | (1 << (JDParser.T__98 - 86)) | (1 << (JDParser.T__99 - 86)) | (1 << (JDParser.T__100 - 86)) | (1 << (JDParser.T__101 - 86)) | (1 << (JDParser.T__102 - 86)) | (1 << (JDParser.T__103 - 86)) | (1 << (JDParser.T__104 - 86)) | (1 << (JDParser.T__105 - 86)) | (1 << (JDParser.T__106 - 86)) | (1 << (JDParser.T__107 - 86)) | (1 << (JDParser.T__108 - 86)) | (1 << (JDParser.T__109 - 86)) | (1 << (JDParser.T__110 - 86)) | (1 << (JDParser.T__111 - 86)) | (1 << (JDParser.T__112 - 86)) | (1 << (JDParser.T__113 - 86)) | (1 << (JDParser.T__114 - 86)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_db

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDb" ):
                listener.enterDb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDb" ):
                listener.exitDb(self)




    def db(self):

        localctx = JDParser.DbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_db)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            _la = self._input.LA(1)
            if not(((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (JDParser.T__115 - 116)) | (1 << (JDParser.T__116 - 116)) | (1 << (JDParser.T__117 - 116)) | (1 << (JDParser.T__118 - 116)) | (1 << (JDParser.T__119 - 116)) | (1 << (JDParser.T__120 - 116)) | (1 << (JDParser.T__121 - 116)) | (1 << (JDParser.T__122 - 116)) | (1 << (JDParser.T__123 - 116)) | (1 << (JDParser.T__124 - 116)) | (1 << (JDParser.T__125 - 116)) | (1 << (JDParser.T__126 - 116)) | (1 << (JDParser.T__127 - 116)) | (1 << (JDParser.T__128 - 116)) | (1 << (JDParser.T__129 - 116)) | (1 << (JDParser.T__130 - 116)) | (1 << (JDParser.T__131 - 116)) | (1 << (JDParser.T__132 - 116)) | (1 << (JDParser.T__133 - 116)) | (1 << (JDParser.T__134 - 116)) | (1 << (JDParser.T__135 - 116)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LangContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return JDParser.RULE_lang

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLang" ):
                listener.enterLang(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLang" ):
                listener.exitLang(self)




    def lang(self):

        localctx = JDParser.LangContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_lang)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            _la = self._input.LA(1)
            if not(((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & ((1 << (JDParser.T__136 - 137)) | (1 << (JDParser.T__137 - 137)) | (1 << (JDParser.T__138 - 137)) | (1 << (JDParser.T__139 - 137)) | (1 << (JDParser.T__140 - 137)) | (1 << (JDParser.T__141 - 137)) | (1 << (JDParser.T__142 - 137)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





